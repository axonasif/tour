{## Đ Compared to Similar Languages #}

{## Đ Compared to Similar Languages #}
export edh'lang'cmp'details = bookmark


{## Target Audience
 # - For developers familiar with some other Object-Oriented, dynamic scripting language
 #} {; import * './grammar'
  {## Target Audience #}
  export edh'lang'cmp'audience = bookmark

  # If you are familiar with any other Object-Oriented, dynamic, scripting language, like Python, JavaScript, Smalltalk etc. , this is for you. You just need to know the differences and a few important gotchas, could save you a great deal of time going over some basic concepts.

  # Familiarity with Haskell is a great plus, as the base Đ interpreter is written in Haskell, and many Đ language constructs are influenced by Haskell.

  # But if you don't know another Object-Oriented dynamic scripting language, some jargons here might not click for you, then please resort to:
  edh'grammar'details # <- follow this link to detailed tour of Đ grammar

  # Alternatively, you can learn Python first if you prefer.
}


{## Đ Code are Auto-Formatted
 # - There is an official code formatter for Đ

You may already know what an opinionated code formatter is, such as Black for Python, Prettier for JavaScript (and HTML, CSS etc.), an Ormolu for Haskell:
  https://black.readthedocs.io
  https://prettier.io
  https://github.com/tweag/ormolu

So it should be no surprise to you, that Đ comes with its own formatter, yet officially:
  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

 #} {;

  # Home page of the formatter should have described the rules and your rights (freedom) well,  after modification, save or right-click to select "Format Document", then you'll see what the formatter thinks.

  # %% # try play with this cell:
  #    add/remove spaces, break it into multip lines, you name it
  1+ ( 2 - 3 ) *5 /9
  # %#

  # TODO any gotcha to be showcased here?

  # For why Đ chose curly braces over indentation rules like Python, see:
  edh'sps'insensitivity

}


{## Optional Semicolons and Commas
 # - Semicolons and commas are technically optional

Examples ought to be enough, and just idiomatic guidelines:

* Avoid semicolons without good reasons
* Place trailing commas where possible

Note semicolons can be really technically omitted in Đ, not the case like in JavaScript that the language does:
  > Automatic Semicolon Insertion <
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

 #} {;

  # The following 5 cells have identical semantics and result value
  # %%
  { a=5; b=3; c=9; }
  # %%
  {; a=5 b=3 c=9 } # <- idiomatic one
  # %%
  { a=5 b=3; c=9 }
  # %%
  { a=5 b=3 c=9; }
  # %%
  { a=5 b=3 c=9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
  # %%
  {, 'a': 5 'b': 3 'c': 9 }
  # %%
  { 'a': 5 'b': 3, 'c': 9 }
  # %%
  { 'a': 5 'b': 3 'c': 9, }
  # %%
  { 'a': 5 'b': 3 'c': 9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; [ 5, 3, 9, ] # <- idiomatic one
  # %%
  ; [, 5 3 9 ]
  # %%
  ; [ 5 3, 9 ]
  # %%
  ; [ 5 3 9, ]
  # %%
  ; [ 5 3 9 ]
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; ( 5, 3, 9, ) # <- idiomatic one
  # %%
  ; (, 5 3 9 )
  # %%
  ; ( 5 3, 9 )
  # %%
  ; ( 5 3 9, )
  # %%
  ; ( 5 3 9 )
  # %#


  {## Cases Disambiguation Needed
   # - However, you'd better be reminded of necessary disambiguations

These examples should work for you.

   #} {;

    {## Disambiguate Unintended Indexing / Calling #}
    export edh'disambig'idx'call = bookmark

    # Noticed the semicolons before each pair of square/round brackets? Why are they there?

    # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


    {## Disambiguate Block from Dict #}
    export edh'disambig'blk'dict = bookmark

    # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

    # %% # Well, check out this:
    type( {; } )
    # %% # Then this:
    type( {} )
    # %#

    # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

    # FYI, in Đ, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exceptin of branches' early break, though, about that later)
    # %% # And an empty block evals to `nil`, check this to be true
    {; } is nil
    # %#

    # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
    # %% # This is a block with a single assignment expression statement
    { a=1 }
    # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
    {; a=1 }
    # %#

    # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when there are risks for it to be mis-interpreted/parsed as a dict literal:
    {;
      # It can still parse as dict literal with comments inside
    }


    # Finally, a comma to disambiguate ArgsPack (a super type of Python tuple), from parenthese-quoted single expression
    # %% # A single argument pack
    ; ( 3*7, )
    # %% # A parenthese-quoted expression
    ; ( 3*7 )
    # %%
    ; type( ( 3*7, ) )
    # %%
    ; type( ( 3*7 ) )
    # %#

  }

}


{## Recommended Line Length
 # - It is under your control, well some advice here

For the record, Đ langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

 #
 #} {;
  # %%
  '''                                                             80 columns ▽
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns △
'''
  # %#
}


{## Common Part with Pervasive Languages
 # - Good interoperability with Python/JavaScript etc. at source level

Đ shares some common syntax with most programming languages (e.g. Python, JavaScript), where parentheses pair is the call-making operator, and expressions consist of named references plus prefix/infix/postfix operators with precedences and associativities, and parentheses again used to override precedence.

 #} {;
  {## Đ Syntax Common To Other Languages #}
  export edh'common'syntax = bookmark

  # %%
  # `console` hooks to the interpreter program's stdio
  # `console.print()` does exactly what you think it should
  console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )

  # %%
  # As a code cell is run by a REPL, the result of evaluation will be printed,
  # so you don't really need `console.print()` that often
  1 + 2 - 3 * 7

  # %%
  # When precedence rule doesn't work outright, parentheses comes to rescue
  1 + ( 2 - 3 ) * 7
  # %#

  {## Minor but Subtle/Surprising Differences
   # - You might be surprised by a few things though
   #} {;

    {## String Literals
     # - Almost all possible forms can be written

In era without code syntax highlighting, multi-line strings can be adversely confusing, but nowadays no text editor can claim itself being a code editor without proper syntax highlighting. So Đ allows a string literal to span multi lines anyway, dunno if this can trip someone up, but be aware.

     #} {;
      {## String Literals #}
      export edh'str'literals = bookmark

      # %%
      'single-quote, single-line string'
      # %%
      'single-quote,
multi-line string'
      # %%
      "double-quote, single-line string"
      # %%
      "double-quote,
multi-line string"
      # %%
      `tick-quote, single-line string`
      # %%
      `tick-quote,
multi-line string`
      # %%
      '''triple-single-quote, single-line string'''
      # %%
      '''triple-single-quote,
multi-line string'''
      # %%
      """triple-double-quote, single-line string"""
      # %%
      """triple-double-quote,
multi-line string"""
      # %%
      ```triple-tick-quote, single-line string```
      # %%
      ```triple-tick-quote,
multi-line string```

      {## Trailing Spaces in Multi-line String Literal
       # - It'll be removed by Đ code formatter

One particar note for multi-line strings, though:
  ALL TRAILING SPACES will be REMOVED by Đ code formatter
That includes such spaces inside a multi-line string literal, you need a workaround just in case.

       #} {;
        {## Trailing Spaces in Multi-line String Literal #}
        export edh'fmt'rm'trail'spc'in'str'lit = bookmark

        # %%
        """You'll need tricks like   """ +
        """this to preserve space(s), which otherwise,
will be at the end of a source line."""
        # %#
      }
    }

    {## Fractional Numbers
     # - Don't take floating point numbers for granted

Floating point arithmetic is intrinsic to numbers in most computer programming languages of today, see:
> What Every Programmer Should Know About Floating-Point Arithmetic
  https://floating-point-gui.de/

Python `float` and JavaScript `number` are all subject to those gotchas.

     #} {;
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You get it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      # Takeaway is:
      #   Numbers in Đ are lossless (within extent of rational numbers)
      # Well please keep in mind that comes at a rather high cost, both spacial and time complexity are much higher to work with numbers in Đ, than in other languages.

      # The overhead is justified for ergonomics concerns where human errors can be disastrous, and raw machine performance should be pursued by perfessionals and by meaning means, such as the approach of `hasdim` you'll see at:
      import * 'dim/tour' into Nothing
    }

    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn

The single quote character (') can appear in an identifier, only if it's not the first character.
     #} {;

      # %%
      # In Haskell and Math, a suffix ' is used to denote something slightly different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' + q' + ' equal to ' + q + " ? That's " + ( q'==q ) + ' of course!'
      # %#

      # There are norms in Haskell for two or even more ' as the suffix, and technically it can appear anywhere except being the start of an identifier, it's the same in Đ

      {## An Unnamed Naming Convention
       # - Or do you know its name?

About naming conventions, quoting:
  http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.

       #} {;
        # %%
        # In Đ more usages of ' can be seen, such as word delimiters in a long identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!DecimalType
        number'of'people = 5
        # %#
        # Note about (::) and (!), they are annotation operators in Đ, will be
        # explained later
      }
    }
  }

}


{## Terminology Differences
 # - Something similar things are called differently

 #} {;

  {## Procedure instead of Function
   # - There are procedures, but no function


   #} {;
    {## Procedure instead of Function #}
    export edh'term'proc'stead'func = bookmark

  }


  {## Attribute instead of Variable
   # - There are attributes, but no variable

Variable in most programming languages is a misconception, ...

   #} {;
    {## Attribute instead of Variable #}
    export edh'term'attr'stead'var = bookmark


  }

}


{## Lexical Structure & Closures
 # - The usual lexical scoping works similar to Python and JavaScript, yet with subtle differences
 #} {;


  {## Value Association Key
   # - What's called *variable identifier* or *variable name* elsewhere

   #} {;
    {## Value Association Keys #}
    export edh'val'asso'keys = bookmark


    {## Usual Keys
     # - Just like how *variable*s can be named in other programming languages such as Python
     #} {;

      # Most programming languages allow only alphanumeric strings as variable identifiers, with limited choices of special characters (such as the usual underscore (`_`), and `$` in Java)

    }

    {## Symbolic Keys
     # - In favor of mythology - or, integration of effectful components from independent vendors
     #} {;

      # JavaScript introduced symbol allowed as identifier of object properties:
      #   https://developer.mozilla.org/en-US/docs/Glossary/Symbol

      # Đ takes this idea further, by giving it dedicated syntax:
      # %%
      symbol @secret'stuff
      # %#

      # It is particularly necessary when a shared scope must be used to serve effectful artifacts collected from various vendors independent of each others, where coordination for name clashing prevention can hardly be done. If they don't use symbolic identifiers for their effects, name clashing is of high tendency.

      # %% # e.g.
      effect import * 'net/effects'
      effect import * 'dim/effects'
      # %#

    }


    {## Quaint Keys
     # - Technically, any string can be used
     #} {;

      # %% # TODO this will fail at runtime, as no REPL with els host modules yet
      import ( @'textDocument/didChange', **_ ) 'els/services'
      desc$ @'textDocument/didChange'
      # %#

    }


  }


  {## Scopes, Entities, and Attributes
   # - No variable, only entities with attributes backing scopes
   #} {;

    # There is not such a thing called variable in Đ ...
    edh'term'attr'stead'var


  }


  {## Modules
   # - Similar to Python Modules

Each `.edh` file is an Đ module

   #} {;
    {## Modules #}
    export edh'modules = bookmark


  }


  {## Namespaces
   # - Similar to TypeScript namespace

An Đ namespace is a special object defined with dedicated syntax

Namespaces are important in Đ, as alternative solutions to certain problems solved differently in other languages.

   #} {;
    {## Namespaces #}
    export edh'namespaces = bookmark

    # Alternative to Python nonlocal semantics

    # Alternative to JavaScript hoisting, - for a piece of code in need of calling a later defined procedure, wrap it in a method procedure of the ns, defined earlier

  }


  {## Scoped Blocks
   # - A usual block doesn't create a scope, but there is special syntax
   #} {;
    {## Scoped Blocks #}
    export edh'scoped'blocks = bookmark


  }


  {## Lexical Scoping Rules
   # - Close to Python/JavaScript, yet with subtle difference

   #} {;
    {## Lexical Scoping Rules #}
    export edh'lexi'rules = bookmark

    {## Attribute Reading
     # - An attribue can be addressed off any scope enclosing the access point

The resolution is from inner-most scope to outer-most scope (which is the world root namespace), which ever matched by attribute key becomes the resolution result

     #} {;
      {## Attribute Reading #}
      export edh'attr'read = bookmark


    }


    {## Attribute Writing
     # - Direct assignment always update the inner-most current scope

There is no way to directly write to any scope other than current scope in context

     #} {;
      {## Attribute Writing #}
      export edh'attr'write = bookmark


    }


    {## Attribute Deletion
     # - Instead of Python's `del` statement and JavaScript's `delete` operator, assignment with `nil` does the trick in Đ


     #} {;
      {## Attribute Deletion #}
      export edh'deletion = bookmark

    }

    {## Closures
     # - Closures are way more coarse grained in Đ

A closure/procedure captures the full lexical scope hierarchy at the point it is defined.

     #} {;
      {## Closures #}
      export edh'closures = bookmark


      {## Compared to Python `nonlocal` Variables
       # - Đ is more dynamic than Python

Đ attribute access

       #} {;
        {## Compared to Python `nonlocal` Variables #}
        export edh'more'dyn'than'py'nonlocal = bookmark


      }

    }

  }

}


{## Object-Oriented, but Not Entirely
 # - Everything is a Value (instead of Object) in Đ

Everything is an Object in Python / Smalltalk, but although Đ is as *Object-Oriented* as Python, *NOT* everything is an object here, such as numbers, strings, and procedures. And there are a handful of special values.

 #} {; import * '../intermediate/objs' # <- navigate to elaboration of Đ Value System

  {## Identity Test Corrected
   # - Object identity has some flaws, value semantics can fix that


   #} {;

  }


  {## Modules and Namespaces are Objects
   # - There are builtin classes for module and namespace respectively


   #} {;
    {## Modules and Namespaces are Objects #}
    export edh'modu'ns'be'obj = bookmark


  }

}


{## Notable Aspects of Đ Value System
 # - Everything is a value in Đ, something is different
 #} {; import * '../intermediate/vals'

  {## Named Values / Term Definitions
   # - Got the familiar (:=) operator for definition
   #} { edh'term'def # <- follow this bookmark to learn more details or just run following cells to get some feel

    # %% # make sure to run this cell before the ones following it
    π := 3.14

    # %% # this prints its name, not value
    repr( π )

    # %% # after arithmetics, it is no more a term,
    repr( π * 1 ) # just an immutable numeric value

    # %% # while type of a term comes from its value
    type( π )

    # %% # and Đ knows it being a term, and can show that accordingly
    show( π )

    # %% # otherwise it's can be used just like an attribute
    r = 1.58
    C = 2 * π * r

    # %#
  }


  {## Đ Vocabulary for Nullability
   # - nil, null, None, Nothing and friends
   #} { edh'nullability # <- follow this bookmark to learn more details
    # or just run following cells to get some feel

    # %% # `nil` will not be printed by REPL
    nil

    # %%
    type( nil ) is nil

    # %% `null()` is the null-test procedure, relatable to the `null`
    # function as in Haskell, but semantically more like:
    #  - Negated *Truth Value Testing* as in Python
    #  https://docs.python.org/3/library/stdtypes.html#truth-value-testing
    # And
    #  - *Falsy Testing* as in JavaScript
    #  https://developer.mozilla.org/en-US/docs/Glossary/Falsy
    # For a dynamic language
    null( nil )
    # %%
    null( 0 )
    # %%
    null( 1 )

    # %% # Note a procedure value will always be *truthy*
    null( null ) # recognize the result please

    # With the mechanism to define named values (i.e. terms), some named *nil* values can be defined for special purpose:

    # %%
    None
    # %%
    Nothing

    # %%
    show( None )
    # %%
    show( Nothing )

    # %%
    None == Nothing
    # %%
    None is Nothing

    # %%
    None == nil
    # %%
    None is nil

    # %%
    Nothing == nil
    # %%
    Nothing is nil

    # %#
  }


  {## Applicability Semantics
   # - We talk about the lack thereof, actually
   #} { import * '../intermediate/appl' # <- navigate to elaboration of Đ Applicability Semantics

    edh'na'semantics # <- follow this bookmark to learn more details

    # %% # NA stands for Not/Applicable, it's a literal constant in Đ
    NA

    # %% # How is it technically working?
    show( NA )

    # %% # The actually `NA` value is a defined constant term, with the value in turn being a *default* expression of literal `nil`, so it is technically a shorthand of `NA := default nil`
    default nil
    # %#

    # More about *default* expressions later, but you just see its repr now for some intuition
  }


  {## Expressions
   # - Lambda without formal argument declaration

A procedure is always called against some object, it also has a formal declaration of its arguments, what if we strip off these properties? The result is: we get expressions.

   #} {;
    {## Expressions #}
    export edh'exprs = bookmark


    {## The `expr` Expression
     # - Original source preserved

Expression is 1st class in Đ, you can create expression values with literal form

     #} {;
      {## The `expr` Expression #}
      export edh'expr'expr = bookmark

      # %%
      x = expr a + b * c

      # %#

    }


    {## Expr Arguments to Procedures
     # - Arguments are passed in expr form, to interpreter procedures and 3af operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

     #} {;
      {## Expr Arguments to Procedures #}
      export edh'expr'args = bookmark

      # %%
      x' = makeExpr( a + b * c )
      # %%
      s.eval( x' )
      # %#

    }


    {## Code as Data
     # - A runnable piece of Đ code is just data from the perspective of the host language/runtime

Đ host procedures (written in Haskell) see Đ AST directly.

     #} {;
      {## Code as Data #}
      export edh'host'proc'exprs = bookmark


    }

  }

}


{## Fancy Operators
 # - Some stylish from Haskell
 #} {;
  {## Đ Operators #}
  export edh'operators = bookmark

  # %%
  console.print$ 'The low-precedence, procedure-call operator `($)` '
  ++ 'can be used for a little stranger syntax.'

  # %% May be even more strange
  show$ ($)
  # %#
  # Run above cell, you should see:
  #  intrinsic: infixr -5 ($)

  # You'd feel familiar if you know about Haskell, `$` is a right-associative, infix operator, of precedence -5 (which is rather low) in Đ (not the core language, but a custom operator from the default batteries technically). The semantics/behavior of ($) is procedure-call in Đ, rather like ($) as the function-application operator in Haskell.

  # To address an operator, you quote it with a pair of parentheses just like in Haskell, so `show$ ($)` should be interpreted as calling procedure `show` with the value of ($) operator procedure (which is first class value in Đ) as the only argument.

  # %% For better understanding, it can be written like this, which is more usual
  op = ($)
  show( op )

  # %%
  console.print$ 'Though the (+) operator works to concatenate strings for'
  + ' Python interoperability, the (++) operator is more idiomatic in Đ'
  ++ ' for string concatenation, resembling Haskell.'

  ; # As you have learned, a semicolon is usually necessary before a starting parentheses, to disambiguate from procedure-call-making, which binds the tightest
  # %% # The pipe operator (|) is flipped ($) operator
  ($) |show
  # %% # This is equivalent to:
  show$ ($)
  # %% # Checkout what the (|) operator is
  show$ (|)
  # %#

  # Note the (|) operator resembles UNIX pipe, while its semantics is more close to the (&) operator in Haskell, which is flipped ($) operator.

  # Some other operators of interest:

  # %%
  show$ (::)
  # %%
  show$ (!)

  # %#
}


{## More or Less Functional than You'd Expect
 # - Roots in Haskell, Go, Python, and JavaScript


 #} {;
}
