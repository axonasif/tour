{## Đ Syntax #}

{## Common Part with Pervasive Languages
 # - Good interoperability with Python/JavaScript etc. at source level
 #
 # Đ shares the common syntax with most programming languages (e.g. Python,
 # JavaScript), where parenthesis pair is the call-making operator, and
 # expressions consist of named references plus prefix/infix/postfix operators
 # with precedences and associativities, and parenthesis again used to override
 # precedence.
 #
 #} { export edh'common'syntax = bookmark

  # %%
  # `console` hooks to the interpreter program's stdio
  # `console.print()` does exactly what you think it should to
  console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )

  # %%
  # As a code cell is run by a REPL, the result of evaluation will be printed,
  # so you don't really need `console.print()` that often
  1 + 2 - 3 * 7

  # %%
  # When precedence rule doesn't work outright, parenthesis comes to rescue
  1 + ( 2 - 3 ) * 7
  # %#

  {## Minor but Surprising Differences
   # - But you might be surprised by sth here
   #} {

    {## Fractional Numbers
     # - Don't take floating point numbers for granted
     #
     # Floating point arithmetic is intrinsic to numbers in most computer
     # programming languages today, see:
     #  * What Every Programmer Should Know About Floating-Point Arithmetic
     #    https://floating-point-gui.de/
     #
     #} {
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You got it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      # Takeaway is:
      #   Numbers in Đ are lossless.
      #
      # But keep in mind, it comes at a rather high cost, both spacial and time
      # complexity are much higher for numbers in Đ than other languages.
      #
      # It's justified for ergonomics concerns where human errors can be
      # disastrous, and raw machine performance should be pursued by meaning
      # means such as the approach of `hasdim` you'll see at:
      import * '../../hasdim' into Nothing
    }

    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn
     #
     # The single quote character (') can appear in an identifier, only if
     # it's not the first character.
     #} {

      # %%
      # In Haskell and Math, a suffix ' is used to denote something slightly
      # different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' + q' + ' equal to ' + q + " ? That's " + ( q'==q ) + ' of course!'
      # There are norms in Haskell for two or even more ' as the suffix, and
      # technically it can appear anywhere except being the start of an
      # identifier, it's the same in Đ
      # %#

      {## An Unnamed Naming Convention
       # - Or do you know its name?
       # ref: http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.
       #} {
        # %%
        # In Đ more usages of ' can be seen, such as word delimiters in a long
        # identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!DecimalType
        number'of'people = 5
        # Note about (::) and (!)
        #   they are annotation operators in Đ, will be explained later
        # %#
      }

    }

    {## Object-Oriented, but Not that Fully
     # - Everything is an Object in Python, not so in Đ
     # details
     #} {

      {## Everything is a Value
       # - Embracing Immutability
       # details
       #} {
        ; # nested code block(s)
      }

      {## Identity Test Corrected
       # - summary
       # details
       #} {
        ; # nested code block(s)
      }

    }

    {## More or Less Functional than You'd Expect
     # - Roots in Haskell, Go, Python, and JavaScript
     # details
     #} {
      ; # nested code block(s)
    }

  }

}

{## Fancy Operators
 # - Let's go some Haskell stylish
 #} { export edh'operators = bookmark

  # %%
  console.print$ 'While the low-precedence, procedure-call operator `($)` '
  ++ 'can be used for a little stranger syntax.'

  # %% May be even more strange
  show$ ($)
  # Run above cell, you should see:
  #  intrinsic: infixr -5 ($)
  # You'd feel familiar if you know about Haskell, `$` is a right-associative,
  # infix operator, of precedence -5 (which is rather low) in Đ (not the core
  # language, but a custom operator from the default batteries technically).
  # The semantics/behavior of ($) is procedure-call in Đ, rather like ($) as
  # the function-application operator in Haskell.

  # To address an operator, you quote it with a pair of parenthesis just like
  # in Haskell, so `show$ ($)` should be interpreted as calling procedure
  # `show` with the value of ($) operator procedure (which is first class
  # value in Đ) as the only argument.

  # %% Written in more usual syntax
  op = ($)
  show( op )

  # %%
  console.print$ 'Though the (+) operator works to concatenate strings for'
  + ' Python interoperability, the (++) operator is more idiomatic in Đ'
  ++ ' for string concatenation, resembling Haskell.'

  # %#
}

{## Auto Indentation, Braces & Semicolons
 # - Whitespaces insignificant, indentation enforced by formatter
 #} {
  ;
}
