{## Đ Syntax #}

{## Common Part with Pervasive Languages
 # - Good interoperability with Python/JavaScript etc. at source level
 #
 # Đ shares the common syntax with most programming languages (e.g. Python,
 # JavaScript), where parenthesis pair is the call-making operator, and
 # expressions consist of named references plus prefix/infix/postfix operators
 # with precedences and associativities, and parenthesis again used to override
 # precedence.
 #
 #} { export edh'common'syntax = bookmark

  # %%
  # `console` hooks to the interpreter program's stdio
  # `console.print()` does exactly what you think it should to
  console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )

  # %%
  # As a code cell is run by a REPL, the result of evaluation will be printed,
  # so you don't really need `console.print()` that often
  1 + 2 - 3 * 7

  # %%
  # When precedence rule doesn't work outright, parenthesis comes to rescue
  1 + ( 2 - 3 ) * 7
  # %#

  {## Minor but Subtle/Surprising Differences
   # - You might be surprised by a few things in Đ
   #} {

    {## Fractional Numbers
     # - Don't take floating point numbers for granted
     #
     # Floating point arithmetic is intrinsic to numbers in most computer
     # programming languages today, see:
     #  * What Every Programmer Should Know About Floating-Point Arithmetic
     #    https://floating-point-gui.de/
     #} {
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You get it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      # Takeaway is:
      #   Numbers in Đ are lossless (within extent of rational numbers).
      #
      # Well please keep in mind that comes at a rather high cost, both spacial
      # and time complexity are much higher to work with numbers in Đ, than in
      # other languages.
      #
      # The overhead is justified for ergonomics concerns where human errors
      # can be disastrous, and raw machine performance should be pursued by
      # perfessionals and by meaning means, such as the approach of `hasdim`
      # you'll see at:
      import * '../../hasdim' into Nothing
    }

    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn
     #
     # The single quote character (') can appear in an identifier, only if
     # it's not the first character.
     #} {

      # %%
      # In Haskell and Math, a suffix ' is used to denote something slightly
      # different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' + q' + ' equal to ' + q + " ? That's " + ( q'==q ) + ' of course!'
      # There are norms in Haskell for two or even more ' as the suffix, and
      # technically it can appear anywhere except being the start of an
      # identifier, it's the same in Đ
      # %#

      {## An Unnamed Naming Convention
       # - Or do you know its name?
       # ref: http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.
       #} {
        # %%
        # In Đ more usages of ' can be seen, such as word delimiters in a long
        # identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!DecimalType
        number'of'people = 5
        # %#
        # Note about (::) and (!), they are annotation operators in Đ, will be
        # explained later
      }

    }

    {## Object-Oriented, but Not Entirely
     # - Everything is a Value (instead of Object) in Đ
     #
     # Everything is an Object in Python / Smalltalk, but although Đ is as
     # *Object-Oriented* as Python, *NOT* everything is an object here, such
     # as numbers, strings, and procedures. And there are a handful of
     # special values.
     #} { import * './vals' # <- navigate to elaboration of Đ Value System

      {## Special Attention
       # - You especially need to know this before other things
       #} {

        {## Named Values / Term Definitions
         # - The familiar := Syntax
         #} { edh'term'def # <- follow this bookmark to learn more details
          # or just run following cells to get some feel

          # %% # make sure to run this cell before the ones following it
          π := 3.14

          # %% # this prints its name, not value
          repr( π )

          # %% # after arithmetics, it is no more a term,
          repr( π * 1 ) # just an immutable numeric value

          # %% # while type of a term comes from its value
          type( π )

          # %% # and Đ knows it being a term, and can show that accordingly
          show( π )

          # %% # otherwise it's can be used just like an attribute
          r = 1.58
          C = 2 * π * r

          # %#
        }

        {## Đ Vocabulary for Nullability
         # - nil, null, None, Nothing and friends
         #} { edh'nullability # <- follow this bookmark to learn more details
          # or just run following cells to get some feel

          # %% # `nil` will not be printed by REPL
          nil

          # %%
          type( nil ) is nil

          # %% `null()` is the null-test procedure, relatable to the `null`
          # function as in Haskell, but semantically more like:
          #  - Negated *Truth Value Testing* as in Python
          #  https://docs.python.org/3/library/stdtypes.html#truth-value-testing
          # And
          #  - *Falsy Testing* as in JavaScript
          #  https://developer.mozilla.org/en-US/docs/Glossary/Falsy
          # For a dynamic language
          null( nil )
          # %%
          null( 0 )
          # %%
          null( 1 )

          # %% # Note a procedure value will always be *truthy*
          null( null ) # recognize the result please

          # With the mechanism to define named values (i.e. terms), some named
          # *nil* values can be defined for special purpose:

          # %%
          None
          # %%
          Nothing

          # %%
          show( None )
          # %%
          show( Nothing )

          # %%
          None == Nothing
          # %%
          None is Nothing

          # %%
          None == nil
          # %%
          None is nil

          # %%
          Nothing == nil
          # %%
          Nothing is nil

          # %#
        }

        {## Applicability Semantics
         # - We talk about the lack thereof, actually
         #} { import * './appl' # <- navigate to elaboration of Đ Applicability Semantics

          edh'na'semantics # <- follow this bookmark to learn more details

          # %% # NA stands for Not/Applicable, it's a literal constant in Đ
          NA

          # %% # How is it technically working?
          show( NA )

          # %% # The actually `NA` value is a defined constant term, with the
          # value in turn being a *default* expression of literal `nil`, so it
          # is technically a shorthand of `NA := default nil`
          default nil
          # %#

          # More about *default* expressions later, but you just see its repr
          # now for some intuition
        }

      }

    }

    {## Identity Test Corrected
     # - summary
     # details
     #} {
      ; # nested code block(s)
    }

  }

  {## More or Less Functional than You'd Expect
   # - Roots in Haskell, Go, Python, and JavaScript
   # details
   #} {
    ; # nested code block(s)
  }

}

{## Fancy Operators
 # - Let's go some Haskell stylish
 #} { export edh'operators = bookmark

  # %%
  console.print$ 'While the low-precedence, procedure-call operator `($)` '
  ++ 'can be used for a little stranger syntax.'

  # %% May be even more strange
  show$ ($)
  # %#

  # Run above cell, you should see:
  #  intrinsic: infixr -5 ($)
  # You'd feel familiar if you know about Haskell, `$` is a right-associative,
  # infix operator, of precedence -5 (which is rather low) in Đ (not the core
  # language, but a custom operator from the default batteries technically).
  # The semantics/behavior of ($) is procedure-call in Đ, rather like ($) as
  # the function-application operator in Haskell.

  # To address an operator, you quote it with a pair of parenthesis just like
  # in Haskell, so `show$ ($)` should be interpreted as calling procedure
  # `show` with the value of ($) operator procedure (which is first class
  # value in Đ) as the only argument.

  # %% Written in more usual syntax
  op = ($)
  show( op )

  # %%
  console.print$ 'Though the (+) operator works to concatenate strings for'
  + ' Python interoperability, the (++) operator is more idiomatic in Đ'
  ++ ' for string concatenation, resembling Haskell.'

  # %% #
  ; # a semicolon is usually necessary before a starting parenthesis,
  # to disambiguate from procedure-calling, which binds the tightest
  ($) |show
  # %% # which is equivalent to the previous
  show$ ($)

  # %% # Checkout what the (|) operator is
  show$ (|)

  # Note the (|) operator resembles UNIX pipe, while its semantics is more
  # close to the (&) operator in Haskell, which is flipped ($) operator.

  # Some other operators of interest:

  # %%
  show$ (::)
  # %%
  show$ (!)

  # %#
}

{## Auto Indentation, Braces & Semicolons
 # - Whitespaces insignificant, indentation enforced by formatter
 #} {
  ;
}
