{## Đ the Language #}


{## What's Đ
 # - A Business Integration language, as well as a User Interface language

**Đ (Edh)** is an _Object-Oriented_, _Dynamic_ _Scripting_ programming language, serving as the surface langauge for interoperation between distributed processes as well as computations within a local process. Where massive **Concurrency** and auto mapping to **Parallelism** are very expected.

Source code in **Đ (Edh)** - the _guest language_, run _interpreted_ atop certain runtime environment programmed in another, more versatile programming language, i.e. the _host langauge_, currently being [GHC](https://haskell.org/ghc)/[Haskell](https://haskell.org). [Julia](https://julialang.org), [Go](https://golang.org), [Python](https://python.org), and [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) are hopefully to be supported in the future.

**Ergonomics** (i.e. _Human Performance_) comes 1st in **Đ (Edh)**'s language design, raw machine performance as well as a prosperous ecosystem and etc. are less a goal, they are offloaded to efforts by the _host language_ and/or _runtime_ .

Đ seeks to be a Business Integration language, as well as a User Interface language, it is born for two main goals:

- To upscale business-oriented integration of distributed, heterogeneous software components

  > State of art architecture requires design of various (restful as you've likely heard of) communication specs, after expensive modeling of the business, then infrastructure and software deployments continuously refactored into distributed spaghetti code.

  > **Đ (Edh)** stands for **Event Distributing & Hosting**, an _event_ is a consistent (but not necessarily atomic) piece of data, encapsulating the information of something just happend in one place, and sent to another place for its consequences to be realized there. _Event_ is conceptually coherent to **Algebraic Data Type** in _type theory_ as well as a functional programming language, but it's not practical to be a mechanical utility in a procedural langauge like Đ. So _event_ stays conceptual in Đ the language.

  > The _event_ abstraction should decouple much of the complexity, and degrade much part of the problem, to be solvable by _Citizen Developers_, especially with the aid of modern software engineering toolings.

- To be directly usable by users of all roles in the organization, especially stake-holders of the business

  > Most people have been accustomed to GUI (Graphical User Interface) for interaction with a computer system, while visual languages still lack sufficient expressiveness in many tasks for global efficiency. Text based communication, governed by grammar (syntax, semantics, pragmatics), can be way more productive and constructive in such cases, and fortunately modern IDEs have filled much of the gap between GUI and TUI (Terminal User Interface), especially when we put Code Lens into good use:

  > > https://code.visualstudio.com/blogs/2017/02/12/code-lens-roundup

  > Inspired by Jupyter code cells:

  > > https://donjayamanne.github.io/pythonVSCodeDocs/docs/jupyter_getting-started/#Running-a-cell-in-a-kernel

  > Each Đ code cell (a piece of code) is individually executable by a single mouse click, on a _Code Lens_ above it reads [Run Cell] (note the click/execution can be repeated).

  > This is much closer to a GUI, yet with more flexible variance & context. The greatest advantage of this tactic is, a user can make slight changes to the code in a template cell, then execute it to achieve tasks in need of a complex phrasing of scription. Traditional TUI requires the user to type out a complete sentence for the job, which needs greatly internalized knowledge about what/how he/she is doing, as well as mental effort nevertheless; while traditional GUI might be just inable to provide the flexibility needed due to level of complexity of the task.

  > So with Đ and its tooling, we can obtain more advantages at the same time, from both worlds: expressiveness from textual languages as well as intuition from visual languages. And Đ is even more _dynamic_ and _interactive_ than Python, also it facilitates effectful functionality composition in a novel way (i.e. _Dynamic Scoped Effects_). From REPLs atop stdio, to WebREPLs, to the extensive IDE features, it's fine-tuned for frictionless developer experience, where anyone could be the developer, and i.e. _Citizen Developer_.

 #} {;
  {## What's Đ #}
  export what's'edh = bookmark
}


{## Utilities
 # - Tools to inspect the world
 #} {; export import * './utils'
  {## Đ Utilities #}
  export edh'utilities = bookmark()

  # TODO briefs & short examples here

}


{## Compared to Similar Languages
 # - An OO dynamic scripting language at-large

If you are familar with Python, JavaScript, or another Object-Oriented dynamic scripting langauge, you should read this chapter instead of (or at least before) the grammar chapter, you'll probably learn the syntax, semantics and pragmatics of Đ faster with your background knowledge about object orientation, lexical scoping and etc. Especially some important gotchas are presented there, those you'd better know before trapped with wrong assumptions about Đ with respect to related features in those other langauges / runtimes.

 #} {; export import * './lang-cmp'
  {## Đ Compared to Similar Languages #}
  export edh'lang'cmp = bookmark()

  # TODO briefs & short examples here

}


{## Grammar
 # - Syntax, Semantics, and Pragmatics of Đ

In lieu of this chapter, you can get all you need to know from the chapter above, if you happen to know some other similar languages. Skip this chapter as you like if that's the case.

Before some more formal language specification is defined, this chapter is a closest thing to that. Hopefully this can serve better for readers without priori backgroud knowledge in programming, or only experienced in functional programming (with Haskell likely), since no priori knowledge about procedure / imperative programming is assumed, and more broken-down examples are presented in this chapter, for easier and more complete understandings.

 #} {; export import * './grammar'
  {## Đ Grammar #}
  export edh'grammar = bookmark()

  # TODO briefs & short examples here

}
