{## Đ Syntax, Semantics, and Pragmatics #}

{## Đ Grammar Details #}
export edh'grammar'details = bookmark()


{## Đ Code Style
 # - Đ code style is officially opinionated
 #} {;
  {## Đ Code Style #}
  export edh'code'style = bookmark

  {## The Official Đ Code Formatter
   # - Any style you like, so long as it is formatted such

Đ encourages (turns-on-by-default) format-on-save, by the official no-config, uncompromised formatter:

  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

The motivation of such a formatter is quite inspired by Black:

  https://black.readthedocs.io

That's to save you time and mental energy for more important matters.

FYI, the original idea comes from Henry Ford's famous quotes about the Model T:

> Any customer can have a car painted any colour that he wants,
> so long as it is black.

   #} {;
    {## The Official Đ Code Formatter #}
    export edh'code'formatter = bookmark

    # Home page of the formatter should have described the rules and your rights (freedom) well,  after modification, save or right-click to select "Format Document", then you'll see what the formatter thinks.

    # %% # try play with this cell:
    #    add/remove spaces, break it into multip lines, you name it
    1+ ( 2 - 3 ) *5 /9
    # %#

    # TODO any gotcha to be showcased here?
  }

  {## Indentation and Brackets
   # - Đ is whitespace insensitive, indentations are infered from brackets

The programmer is responsible for the brackets (scoping), while the formatter is in charge of proper indentation.

   #} {;

    {## Whitespace Sensitivity is Outdated
     # - Indentation can be inferred, no reason to DIY today

>> Why Python’s whitespace rule is right <<
   https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right

>> There is not a single situation in any country, in any programming language, or at any skill level, in which is it acceptable to not indent your code the way Python requires it.

This is much agreeable even at today.

>> When you really analyse it, Python’s whitespace sensitivity is actually the only logical choice for a programming language, ...

Well, this conclusion holds right in its time, when auto code formatters are still some luxury to have. But today, besides the compiler(s), we are affording way more expensive analyzing tools like linters, test runners, coverage, profilers, and usually comprehensive langauge servers, amongst which code formatters become rather commonplace.

Scopes (either lexical or conceptual) have to be decided and expressed by the programmer, but even excluding extreme cases, a code block can consist of up to hundreds of lines, it's ridiculous to manually maintain proper indentation for every line, when the formatter can painlessly do it for you.

Whitespace sensitivity has become outdated now, brackets (curly, square or round) come handy-dandy to express various scopes in your mind, just leave indentation for the formatters to care about.

     #
     #} {;
      {## Đ is Whitespace Insensitive #}
      export edh'sps'insensitivity = bookmark

      # TODO showcases here?
    }
  }


  {## Semicolons and Commas
   # - They are optional everywhere in Đ, unless for disambiguation

For the record, in Đ code it's considered idiomatic to:

* Avoid semicolons unless absolutely necessary
* Place trailing commas where possible

Note semicolons can be really technically omitted in Đ, not the case like in JavaScript that the language does:
  > Automatic Semicolon Insertion <
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

   #} {;
    {## Semicolons and Commas #}
    export edh'semicolons'and'commas = bookmark

    # Semicolons and commas are said to be optional in Đ, which means, leading ones, trailing ones, as well as middle ones, all can be omitted. Let's see some examples with the idiomatic form pointed out.

    # The following 5 cells have identical semantics and result value
    # %%
    { a=5; b=3; c=9; }
    # %%
    {; a=5 b=3 c=9 } # <- idiomatic one
    # %%
    { a=5 b=3; c=9 }
    # %%
    { a=5 b=3 c=9; }
    # %%
    { a=5 b=3 c=9 }
    # %#

    # The following 5 cells too, have identical semantics and result value
    # %%
    { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
    # %%
    {, 'a': 5 'b': 3 'c': 9 }
    # %%
    { 'a': 5 'b': 3, 'c': 9 }
    # %%
    { 'a': 5 'b': 3 'c': 9, }
    # %%
    { 'a': 5 'b': 3 'c': 9 }
    # %#

    # The following 5 cells too, have identical semantics and result value
    # %%
    ; [ 5, 3, 9, ] # <- idiomatic one
    # %%
    ; [, 5 3 9 ]
    # %%
    ; [ 5 3, 9 ]
    # %%
    ; [ 5 3 9, ]
    # %%
    ; [ 5 3 9 ]
    # %#

    # The following 5 cells too, have identical semantics and result value
    # %%
    ; ( 5, 3, 9, ) # <- idiomatic one
    # %%
    ; (, 5 3 9 )
    # %%
    ; ( 5 3, 9 )
    # %%
    ; ( 5 3 9, )
    # %%
    ; ( 5 3 9 )
    # %#


    {## Disambiguate Unintended Indexing / Calling #}
    export edh'disambig'idx'call = bookmark

    # Noticed the semicolons before each pair of square/round brackets? Why are they there?

    # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


    {## Disambiguate Block from Dict #}
    export edh'disambig'blk'dict = bookmark

    # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

    # %% # Well, check out this:
    type( {; } )
    # %% # Then this:
    type( {} )
    # %#

    # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

    # FYI, in Đ, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exceptin of branches' early break, though, about that later)
    # %% # And an empty block evals to `nil`, check this to be true
    {; } is nil
    # %#

    # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
    # %% # This is a block with a single assignment expression statement
    { a=1 }
    # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
    {; a=1 }
    # %#

    # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when there are risks for it to be mis-interpreted/parsed as a dict literal:
    {;
      # It can still parse as dict literal with comments inside
    }


    # Finally, a comma to disambiguate ArgsPack (a super type of Python tuple), from parenthese-quoted single expression
    # %% # A single argument pack
    ; ( 3*7, )
    # %% # A parenthese-quoted expression
    ; ( 3*7 )
    # %%
    ; type( ( 3*7, ) )
    # %%
    ; type( ( 3*7 ) )
    # %#

  }


  {## Recommended Line Length
   # - It is under your control, well some advice here

For the record, Đ langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

   #
   #} {;
    {## Recommended Line Length #}
    export edh'line'len'adivce = bookmark

    # %%
    '''                                                             80 columns ▽
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns △
'''
    # %#
  }

}


{## Classes
 # - Compositional Multiple-Inheritance with Multiple-Prototype Chains
 #} {; import * '../intermediate/objs'
  {## Đ Classes #}
  export edh'classes = bookmark


  {## Data Classes
   # - Python PEP-557 (Data Classes) got dedicated syntax in Đ

Beyond PEP-557 features in a dedicated syntax, Đ data classes especially shines in pattern matching use cases, closely mimics ADT, predating PEP-634 (which is upcoming in Python 3.10).

   #} {;
    {## Data Classes #}
    export edh'data'classes = bookmark


  }


  {## Usual Classes
   # - A data class is still a usual class under the hood

The `class` keyword defines a usual class.

   #} {;
    {## Usual Classes #}
    export edh'usual'classes = bookmark


    # %%
    class B pass
    class C extends B
    class D extends C
    class E extends (D,B)
    # %%
    E.mro
    # %%
    o = C()
    o.a = 5
    # %%
    dir$ o

    # %#
  }

}


{## Modules and Namespaces
 # - `module` and `namespace` are two special builtin classes


 #} {;
  {## Modules and Namespaces #}
  export bookmark'identifier = bookmark


}


{## Lexical Scopes
 # - Every scope is backed by an entity with an (implicit) identity, plus a dynamic set of attributes

Every scope can be wrapped as an object of `scope` class

 #} {;
  {## Lexical Scopes #}
  export edh'lexi'scopes = bookmark

  # %%
  s = scope()
  # %%
  s.attrs() |type
  # %%
  dir$ s
  # %%
  s.put( a= 5, b=2, )
  s.eval( expr c = 3 )
  # %%
  dir$ s
  # %%
  s.eval( expr c += 2 )
  s.get( 'c' )
  # %#

}


{## Procedures
 # - Đ is functional to such an extent

Several type of procedures, the lambda forms (arrow procedures), and expression being 1st class as well


 #} {;
  {## Procedures #}
  export edh'procs = bookmark


  {## Methods, Bound and Unbound
   # - Procedures owned by some object

All procedures are methods of some object, but a particular method doesn't have to be bound

   #} {;
    {## Methods, Bound and Unbound #}
    export edh'mths'bound'unbound = bookmark


  }


  {## This/That/Super Reference
   # - A class of multiple inheritance creates composite objects

Đ follows JavaScript/Java/C++ to use `this` keyword, instead of Python's `self`, however this is not a simple choice end here.


`that` reference solves a problem akin to the slicing problem of C++
  https://en.wikipedia.org/wiki/Object_slicing


   #} {;
    {## This/That/Super Reference #}
    export edh'this'that'super'ref = bookmark


  }


  {## Closure
   # - A procedure always captures the full lexical context it is defined in

Đ closure is rather coarse grained.

   #} {;
    {## Closure #}
    export edh'closure = bookmark


  }

}


{## Expressions
 # - Lambda without formal argument declaration

A procedure is always called against some object, it also has a formal declaration of its arguments, what if we strip off these properties? The result is: we get expressions.

 #} {;
  {## Expressions #}
  export edh'exprs = bookmark


  {## The `expr` Expression
   # - Original source preserved

Expression is 1st class in Đ, you can create expression values with literal form

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark

    # %%
    x = expr a + b * c

    # %#

  }


  {## Expr Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3af operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expr Arguments to Procedures #}
    export edh'expr'args = bookmark

    # %%
    x' = makeExpr( a + b * c )
    # %%
    s.eval( x' )
    # %#

  }

  {## Code as Data
   # - A runnable piece of Đ code is just data from the perspective of the host language/runtime

Đ host procedures (written in Haskell) see Đ AST directly.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark


  }

}
