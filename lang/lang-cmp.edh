{## Đ Compared to Similar Languages #}

{## Đ Compared to Similar Languages #}
export edh'lang'cmp'details = bookmark()


{## Target Audience
 # - For developers familiar with some other Object-Oriented, dynamic scripting language

If you are familiar with any other Object-Oriented, dynamic, scripting language, like Python, JavaScript, Smalltalk etc, this is for you. You just need to know the differences and a few important gotchas, could save you a great deal of time going over some basic concepts.

Familiarity with Haskell is a great plus, as the base Đ interpreter is written in Haskell, and many Đ language constructs are influenced by Haskell.

 #} {;
  {## Target Audience #}
  export edh'lang'cmp'audience = bookmark()

  # But if you don't know another Object-Oriented dynamic scripting language, some jargons here might not click for you, then please read the chapter of Đ grammar instead
  import * './grammar'
  edh'grammar'details # <- follow this bookmark to there

  # Alternatively, you can learn Python first if you prefer.
}


{## Overview
 # - General reason of most design choices

The Đ grammar is designed with a major goal of interoperation by scripting, for IPC (Inter-Process Communication) across processes of heterogeneous runtime implementations. So as to finally integrate massive scale of software compoonents (possibly independently developed by many vendors) into live systems.

While some constructs from Haskell, Go, Python and others, are introduced
for purpose of ergonomics. E.g.

- custom infix operators, with arbitrary associativity and precedence
    * from Haskell, C++ etc.

- pattern matching & branching
    * from typical FP languages, as well as upcoming PEP-634 of Python

- goroutine
    * from Go

- compositional object
    * sorta from Go type embedding, and C++ multiple-inheritance

- class based inheritance
    * from Python, Smalltalk etc.

- C3 linearized multiple inheritance
    * from Python, which is in turn from Dylan

- magic object methods
    * from Python

- data classes
    * from Python PEP-557

- prototype based inheritance
    * from JavaScript

- fat-arrow procedure (lambda)
    * from JavaScript, while the lambda aspect from all multi-paradigm languages with FP in mind, including JavaScript and Python

- symbols
    * from JavaScript, yet much enhanced

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


{## Format-on-Save
 # - There is an official code formatter for Đ

You may already know what an opinionated code formatter is, such as Black for Python, Prettier for JavaScript (and HTML, CSS etc.), an Ormolu for Haskell:
  https://black.readthedocs.io
  https://prettier.io
  https://github.com/tweag/ormolu

So it should be no surprise to you, that Đ comes with its own formatter, yet officially:
  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

And note that Đ formatter is by default invoked on saving of `.edh` source files, Go tooling works this way, while other mainstream languages don't.

 #} {;

  # Home page of the formatter should have described the rules and your rights (freedom) well,  after modification, save or right-click to select "Format Document", then you'll see what the formatter thinks.

  # Hint: With VSCode, the default shortcut key for "Format Document", on macOS is Shift+Option+F and Ctrl+Shift+I on Linux

  # %% # try play with this cell:
  #    add/remove spaces, break it into multip lines, you name it
  1+ ( 2 - 3 ) *5 /9
  # %#

  # TODO any gotcha to be showcased here?

  # For why Đ chose curly braces over indentation rules like Python, see:
  edh'sps'insensitivity

}


{## Optional Semicolons and Commas
 # - Semicolons and commas are technically optional

Just examples ought to be enough, plus guidelines for idiomatics:

 * Avoid semicolons - unless for disambiguation
 * Place trailing commas where possible - unless it's more concise without it

Note semicolons can be really technically omitted in Đ, not the case like in JavaScript, that the language does [Automatic Semicolon Insertion]
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

 #} {;

  # The following 5 cells have identical semantics and result value
  # %%
  { a=5; b=3; c=9; }
  # %%
  {; a=5 b=3 c=9 } # <- idiomatic one
  # %%
  { a=5 b=3; c=9 }
  # %%
  { a=5 b=3 c=9; }
  # %%
  { a=5 b=3 c=9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
  # %%
  {, 'a': 5 'b': 3 'c': 9 }
  # %%
  { 'a': 5 'b': 3, 'c': 9 }
  # %%
  { 'a': 5 'b': 3 'c': 9, }
  # %%
  { 'a': 5 'b': 3 'c': 9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; [ 5, 3, 9, ] # <- idiomatic one
  # %%
  ; [, 5 3 9 ]
  # %%
  ; [ 5 3, 9 ]
  # %%
  ; [ 5 3 9, ]
  # %%
  ; [ 5 3 9 ]
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; ( 5, 3, 9, ) # <- idiomatic one
  # %%
  ; (, 5 3 9 )
  # %%
  ; ( 5 3, 9 )
  # %%
  ; ( 5 3 9, )
  # %%
  ; ( 5 3 9 )
  # %#


  {## Cases Disambiguation Needed
   # - However, you'd better be reminded of necessary disambiguations
   #} {;

    {## Disambiguate Unintended Indexing / Calling #}
    export edh'disambig'idx'call = bookmark()

    # Noticed the semicolons before each pair of square/round brackets? Why are they there?

    # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


    {## Disambiguate Block from Dict #}
    export edh'disambig'blk'dict = bookmark()

    # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

    # %% # Well, check out this:
    type( {; } )
    # %% # Then this:
    type( {} )
    # %#

    # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

    # FYI, in Đ, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exception of branches' early break, though, and about that later)
    # %% # And an empty block evals to `nil`, check this to be true
    {; } is nil
    # %#

    # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
    # %% # This is a block with a single assignment expression statement
    { a=1 }
    # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
    {; a=1 }
    # %#

    # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when there are risks for it to be mis-interpreted/parsed as a dict literal:
    {;
      # It can still parse as dict literal with comments inside
    }


    # Finally, a comma to disambiguate ArgsPack (a super type of tuple like in Python), from parenthese-quoted single expression
    # %% # A single arguments pack
    ; ( 3*7, )
    # %% # A parenthese-quoted expression
    ; ( 3*7 )
    # %%
    ; type( ( 3*7, ) )
    # %%
    ; type( ( 3*7 ) )
    # %#

  }

}


{## Recommended Line Length
 # - It is under your control, well some advice here

For the record, Đ langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

 #} {;
  # %%
  '''
                                                                    80 columns ▽
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns △
'''
  # %#
}


{## Common Parts with Pervasive Languages
 # - Đ has good interoperability with Python/JavaScript etc. at source level

Đ shares some common syntax with many popular programming languages (e.g. Python, JavaScript), in a nutshell:

 * Parentheses pair is the call-making operator
 * Expressions consist of named references, joined together by prefix/infix/postfix operators with certain precedence and fixity/associativity
 * Parentheses for precedence override

 #} {;

  {## Common Syntax
   # - Đ syntax common to many popular languages
   #} {;
    {## Đ Common Syntax #}
    export edh'common'syntax = bookmark()

    # `console` hooks to the interpreter program's stdio
    # `console.print()` does exactly what you think it should
    # %%
    console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )
    # %#

    # As a code cell is run by a REPL, the result of evaluation will be printed,
    # so you don't really need `console.print()` that often
    # %%
    1 + 2 - 3 * 7
    # %#

    # When precedence rule doesn't work outright, parenthese comes to rescue
    # %%
    1 + ( 2 - 3 ) * 7
    # %#
  }


  {## Module System
   # - Blend of several popular things
   #} {;
    {## Module System #}
    export edh'modu'system = bookmark()

    {## Node.js Package Directory Hierarchy
     # - Directory layout for package deployment

  https://nodejs.org/api/modules.html

But you use `epm` to initialize EPM homes, install / update / remove pakcages in each home manually, instead of the full-automatic `npm` tool.

  https://github.com/e-wrks/epm

     #} {;
      {## Node.js Package Directory Hierarchy #}
      export edh'pkg'layout = bookmark()
    }


    {## ES6 import/export Syntax
     # - Dedicated `import` and `export` keyword

  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules

You use explicit `export` keyword to decorate artifact definitions (e.g. assignments, procedure/class declarations), for them to be importable by other modules (or objects).

The `import` keyword is used to denote an import expression, the expression evaluates to the object resolved as the source for import, and with a side effect of artifacts exported from that object to be received into current scope, however specified by the arguments receiver part of the import expression.

     #} {;
      {## ES6 import/export Syntax #}
      export edh'imp'exp'syntax = bookmark()

      # Note that the import/export mechanism works with any object in Đ, module objects as well
      edh'imp'exp # <- follow this bookmark to the section describing the detailed syntax and semantics in the grammar chapter

    }


    {## Python Module File Naming Convention
     # - Special module files like `__init__.edh` and `__main__.edh`

  https://docs.python.org/3/tutorial/modules.html

Đ module files ends with `.edh` extension name, special cases include:

 * `__init__.edh` can stand for the import target as its parent directory, relative imports within it work more intuitively than a file module with its parent folder's name plus the `.edh` suffix.

 * `__main__.edh` stands for the entry module source file, when its parent directory is resolved as the entry module of an interpreter process.

Note that `__main__.edh` is the only valid entry module file name, unlike Python. An otherwise named module file will never be run as an entry module.

     #} {;
      {## Python Module File Naming Convention #}
      export bookmark'identifier = bookmark()
    }


    {## Python Module Semantics
     # - Strict loading and meta artifacts

The module loading semantics is similar to Python, every statements at top levels will be strictly executed in a sequence. The cyclic importing (with possibly multiple levels of indirections) cases are also similar to those in Python.

     #} {;
      {## Python Module Semantics #}
      export edh'modu'loading'meta'arts = bookmark()

      edh'modu'load'cyc # <- follow this bookmark for detailed describption of loading semantics, including cyclic loading cases


      {## Reflective Attributes in a Module
       # - Every module object contains some meta attribute to reflect its source information
       #} {;

        # %% # It should at lease contain the `__name__` attribute, similar to Python
        __name__

        # %% # File modules should contain `__file__` for absolute file path of the source file as well, similar to Python
        __file__

        # %% # Also `__path__` to be used as basis for relative import from within the very module, this is beyond Python
        __path__

        # %#
      }

    }

  }


  {## Minor but Subtle/Surprising Differences
   # - You might be surprised by a few things though
   #} {;

    {## String Literals
     # - Almost all possible forms are valid here

In an era without code syntax highlighting, multi-line strings can be adversely confusing, but nowadays no text editor can claim itself being a code editor without proper syntax highlighting. So Đ allows a string literal to span multi lines anyway, dunno if this can trip someone up, but be aware.

     #} {;
      {## String Literals #}
      export edh'str'literals = bookmark()

      # %%
      'single-quote, single-line string'
      # %%
      'single-quote,
multi-line string'
      # %%
      "double-quote, single-line string"
      # %%
      "double-quote,
multi-line string"
      # %%
      `tick-quote, single-line string`
      # %%
      `tick-quote,
multi-line string`
      # %%
      '''triple-single-quote, single-line string'''
      # %%
      '''triple-single-quote,
multi-line string'''
      # %%
      """triple-double-quote, single-line string"""
      # %%
      """triple-double-quote,
multi-line string"""
      # %%
      ```triple-tick-quote, single-line string```
      # %%
      ```triple-tick-quote,
multi-line string```

      {## Trailing Spaces in Multi-line String Literal
       # - It'll be removed by Đ code formatter

One particar note for multi-line strings, though:
  ALL TRAILING SPACES will be REMOVED by Đ code formatter
That includes such spaces inside a multi-line string literal, you need a workaround just in case.

       #} {;
        {## Trailing Spaces in Multi-line String Literal #}
        export edh'fmt'rm'trail'spc'in'str'lit = bookmark()

        # %%
        """You'll need tricks like   """ +
        """this to preserve space(s), which otherwise,
will be at the end of a source line."""
        # %#
      }
    }

    {## Rational Decimal Numbers
     # - Don't take floating point numbers for granted

Floating point arithmetic is intrinsic to numbers represented natively in most computer programming languages of today, see:

> What Every Programmer Should Know About Floating-Point Arithmetic
  https://floating-point-gui.de/

Python `float` and JavaScript `number` are all subject to those gotchas.

     #} {;
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You get it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      edh'rat'decimal # <- follow this bookmark to the detailed section in the grammar chapter

      # Takeaway is:
      #   Numbers in Đ are lossless (to the extent of rational numbers)
      # Well please keep in mind that comes at a rather high cost, both spacial and time complexity are much higher to work with numbers in Đ, than in other languages.

      # The overhead is justified for ergonomics concerns where human errors can be disastrous, and raw machine performance should be pursued by perfessionals and by meaning means, such as the approach of `hasdim` you'll see at:
      import * 'dim/tour' into Nothing
    }


    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn

The single quote character (') can appear in an identifier, only if it's not the first character.

     #} {;

      # %% # In Haskell and Math, a suffix ' is used to denote something slightly different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' + q' + ' equal to ' + q + " ? That's " + ( q'==q ) + ' of course!'
      # %#

      # There are norms in Haskell for two or even more ' as the suffix, and technically it can appear anywhere except being the start of an identifier, it's the same in Đ

      {## An Unnamed Naming Convention
       # - Or do you know its name?

About naming conventions, quoting:
  http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.

       #} {;

        # %% # In Đ more usages of ' can be seen, such as word delimiters in a long identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!DecimalType
        number'of'people = 5
        # %# Note about (::) and (!), they are annotation operators in Đ, will be explained later

      }
    }
  }

}


{## Terminology Differences
 # - Some similar things are named differently
 #} {;

  {## Procedure instead of Function
   # - There are procedures, but no functions

A *function* in mathematics has well defined input and output, it can refer to nothing outside of its immutable input (though with enclosed implicit parameters included). Functional programming langauges e.g. Haskell, reflects such constraint well. But unfortunately many procedural / imperative programming langauges, tracing back to C and other ancestors, defined their "function"s with ability to access mutable global / closure "variable"s (The "variable" there is albeit another misconception agsinst mathematical variables), so side-effects can be there out of trivial reasonability by programmers in the day, leading to more bugs in software developed comercially.

It's not a big deal for Đ the language to have stopped refering to impure computations (with side-effects and mutable input) as "function"s, but more conforming conception is a good start to put effect tracking as a focus for the programming tools, looking forward for greater quality in the software developed as the result.

   #} {;
    {## Procedure instead of Function #}
    export edh'term'proc'stead'func = bookmark()
  }


  {## Attribute instead of Variable
   # - There are attributes, but no variables

There is no such a concept/term of "variable" in Đ. The "variable" concept in conventional programming languages is misleading or conflicting when you could possibly have mathematical concepts in the domain model of your business. More properly it should be called "assignable" as suggested in:
  https://existentialtype.wordpress.com/2013/07/22/there-is-such-a-thing-as-a-declarative-language

Although attributes of entities in Đ are inherently meant to be assigned (as well as to be observed), they can not stand alone without a backing entity. Unlike in conventional programming languages, where a "variable" can be assigned individually.

   #} {;
    {## Attribute instead of Variable #}
    export edh'term'attr'stead'var = bookmark()
  }

}


{## Code Structure & Semantics
 # - Similar to Python, JavaScript, etc. but with subtle differences

Đ source code is organized as modules, some defined by code in the host programming language, some loaded from respective source files from the filesystem. Modules export artifacts for reuse, while importing artifacts from others, quite similar to Python codebases or JavaScript codebases consisting of ES6 modules.

Closure in Đ is more coarse grained - entire scopes, instead of individual "variable"s are enclosed. It makes Đ programs more potent to resource leaks though, so more care should be taken by the programmer, to clear references to resource values as soon as not needed anymore.

 #} {;
  {## Code Structure & Semantics #}
  export edh'code'struct = bookmark()


  {## Name / Identifier
   # - The so called *variable identifier* or *variable name* elsewhere

All data in an Đ world is stored as attributes associated with certain entities under some name. Both (non-host) objects and scopes are backed by entities, the naming mechnism works at the entity level, so stays the same for both objects and scopes.

   #} {;
    {## Name / Identifier #}
    export edh'name'identifer = bookmark()

    {## Usual, Alphanumeric Names
     # - Just like how *variable*s can be named in other programming languages such as Python
     #} {;

      # Most programming languages allow only alphanumeric strings as "variable" identifiers, with limited choices of special characters (such as the usual underscore (`_`), and `$` in Java)

      # Đ allows underscore (_) and the single-quote character (') in alphanumeric names, this is following Haskell, and more scientific naming friendly.

      edh'alphanum'names # <- follow this bookmark to the detailed secion in the grammar chapter

    }


    {## Symbolic Names
     # - Cross component encapsulation of implementation details

JavaScript introduced symbol, which is allowed as identifier of object properties:
  https://developer.mozilla.org/en-US/docs/Glossary/Symbol

Đ takes this idea further, gives it bigger purpose, and dedicated syntax.

Like other dynamic programming languages such as Python, JavaScript, Đ objects (and scopes) are openly accessible, but with symbol key values eligible as symbolic attribute names, Đ programming interfaces can have multiple level of encapsulation, that even more flexible than what's supported by Java, C++ and similar languages.

Java has private/protected/public and the implicit package qualification to limit access to fields of a class, C++ has private/protected/public qualification plus friend declarations. In Đ, you define symbols to be used as the name of such fields (attributes of objects / scopes), then you can export the symbol key values differently than how the class (or namespace etc.) is exported. Other components can import these keys and use them to access such symbolic fields, as if they are public, or those fields will appear private/hidden to them. Different contracts with different sets of available symbols can be defined and exposed to different parties, for different levels of knowledge & access to the same codebase of implementation details.

     #} {;

      edh'symbolic'names # <- follow this bookmark to the detailed description of symbolic names and at-notations in the grammar chapter


      # %% # The `symbol` keyword is used to define new symbol keys
      symbol @secret'stuff

      # %% # Directly assign to symbolic attribute into current scope
      ; @secret'stuff = 'a bit of mysterious'

      # %% # Directly obtain a symbolic attribute from current scope
      ; @secret'stuff

      # %% # The at-notation works as argument name, as well as attribute name in dot-notation
      namespace shared'ns ( @secret'stuff= 'This is public to whoever knows the key', ) {

        # Assign symbolic object attribute with dot-notation
        this.@secret'stuff ++= ", but private to ones don't."

      }

      # %% # Obtain symbolic object attribute value via dot-notation
      shared'ns.@secret'stuff

      # %#
    }


    {## Quaint Names
     # - Technically, any text can be used as attribute name

Special characters don't get in the way for you to use strings containing them as attribute identifiers. This comes handy in some cases, e.g. LSP (Language Server Protocol) service names tend to have slash `/` characters in it, but the Đ language server defines such service methods with verbatimly such names in the code, while you have to use dynamic data structures for such implementations in other languages.

     #} {;

      edh'quaint'names # <- follow this bookmark to the detailed section in the grammar chapter

      # %% # Assign an attribute with a dash in its name
      shared'ns.@'full-time' = true

      # %% # Obtain such an attribute
      shared'ns.@'full-time'

      # %% # Check all attributes there
      dir$ shared'ns

      # %#
    }

  }


  {## Attribute Deletion
   # - By assigning `nil` to it

Instead of Python's `del` statement and JavaScript's `delete` operator, assignment with `nil` does that job in Đ

   #} {;
    {## Attribute Deletion #}
    export edh'attr'deletion = bookmark()

    # %% # A usual assignment
    x = 3

    # %% # Check it does be in scope
    x

    # %% # Deleting it
    x = nil

    # %% # Try obtains it now
    x

    # %# See? Not in scope anymore, after deletion.

  }


  {## Scope and Call Stack
   # - Lexical (static) scoping & effect (dynamic) scoping

Lexical scoping rules of Đ are comparable to that of Python, JavaScript etc. but with gotchas.

Đ also does dynamic scoping to foster effect tracking, which is never supported in similar languages.

   #} {;
    {## Scope and Call Stack #}
    export edh'scope'callstack = bookmark()

    edh'scope'hierarchies # <- follow this bookmark to the detailed description in the grammar chapter

    {## Lexical Attribute Resolution & Shadowing
     # - Similar to "variable" resolution in Python, JavaScript etc.

Direct attribute obtaining is very close to "variable" reading in similar languages, that inner scope attribute with the same name will shadow those live in outer scopes. But it is more dynamic in Đ - the attribute can be deleted from the inner scope, then your reads will immediately resolve to an outer attribute previously shadowed - this is not the case with either Python or JavaScript.

But you have no way to assign attributes into an outer scope (there are workarounds though), scoped assignments (not with dot-notation as target) will always go into current scope. There is neither `nonlocal` hints as in Python, nor explicit "variable" declaration (the `var` keyword) as in JavaScript. Prevalent dynamic namespace objects should be the norm in Đ code, to convey artifacts meant to be assigned by code running in inner scopes, via dot-notations.

     #} {;
      {## Lexical Attribute Resolution & Shadowing #}
      export edh'lexi'resolv = bookmark()

      # %% # We demonatrate it with a scoped block here
      x = 'outer-value'
      {@
        console.print$ 'Inside, before local attr definition, x is: ' ++ x
        # Upon entering a scoped block, a new lexical inner scope (backed by a separate entity) is created right away, then attributes can be defined locally. And an attribute present in an inner scope shadows all ones with the same name from outer scopes.
        x = 'inner-value'
        console.print$ 'Inside, after local attr definition, x is: ' ++ x
        # Dynamic deletion of an attribute works and matters here
        x = nil
        console.print$ 'Inside, after local attr deleted, x is: ' ++ x
        # All attributes left in a scope will be discarded, after control leaves the scope (unless some procedures defined in the scope are sent out and kept live elsewhere, as those procedures _enclose_ their lexical contextual scopes)
        x = 'inner-again'
      @}
      console.print$ 'Outside, x is: ' ++ x
      # %# No access to artifacts in an inner scope from outer

      # Note it is an anti-pattern to shadow attributes living in outer scopes, the code above is for demonstration purpose only and not idiomatic. Scoped blocks should be just used to discard its scope attributes upon leaving, it's discouraged to override attributes available from outer scopes like that.


      # %% # Ad-hoc defined namespaces can serve as the container of attributes assignable by any code having read access to the namespace object

      namespace state (n= 10) pass

      method count'down() state.n -= 1

      # %% # See it works (run this cell more times for better intuition)
      count'down()
      state.n

      # %#
    }


    {## Effect Tracking by Dynamic Scoping
     # - A unique feature of Đ

Dynamic scoping - attribute resolution against the calling stack of caller frames - is seldom seen in modern programming languages anymore, but Đ is doing it for effect tracking, with solution to its historical problems.

     #} {;
      {## Effect Tracking by Dynamic Scoping #}
      export edh'eff'tracking'by'dyn'scoping = bookmark()

      edh'dyn'scoping # <- follow this bookmark to the detailed description in the grammar chapter

    }

  }


  {## Namespaces
   # - Similar to TypeScript namespace

An Đ namespace is a special object defined with dedicated syntax. It's fairly norm to create namespaces ad-hoc during a procedure call, which carries more dynamic semantics, in addition to more "statically" defined namespaces at top level of module initialization.

   #} {;
    {## Namespaces #}
    export edh'namespaces = bookmark()

    edh'namespaces # <- follow this bookmark for the detailed syntax and description in the grammar chapter

    # Alternative to Python `nonlocal` "variables", namespaces live in outer scope can hold attributes meant to be assigned by some code run in inner scopes.

    # Alternative to JavaScript hoisting, a procedure can be defined earlier to contain code wanting to call other procedures defined later.

  }


  {## Scoped Blocks
   # - A usual block doesn't create a nested scope, use special syntax to do that

Unlike in C and its offsprings, rather like in Python, JavaScript, Go etc. a usual (indentation denoted in Python, curly brace denoted in JS and Go) block in Đ does not create a nested scope.

You have to use an ad-hoc'ly called "function" in Python, JS or Go, to create nested scopes, sth what you do with just curly braces in C family languages (including Java, C++ etc.). Đ offers special syntax to do it easily.

   #} {;
    edh'scoped'blocks # <- follow this bookmark to the detailed description in the grammar chapter

    # %% # A scoped block is denoted by a pair of curly braces augmented with at (@) symbol. As with a usual scope, it evaluates to result of the last statement (usually an expression statement) in it

    y = nil # Let's clear `y` out of the REPL top scope for sure

    { # This starts a usual block

      x = 3 # This goes into the REPL top scope, as evaluated in a usual block

      {@ # This starts a scoped block

        y = 7 # This goes into the scope created by the scoped block

        x * y # This provides the result value for the whole scoped block, as last expression in it

      @} # This ends the scoped block. Note `y` is not in scope since here on

    } # This ends the usual block, with the result from that of the inner scoped block, as the scoped block is the last statement of this usual block

    # %% # The nested scope created by a scoped block goes out after execution left that block
    x + y
    # %# See the error? `y` is not in scope here

  }


  {## Coarse Grained Closure
   # - A procedure always captures the full lexical context where it is defined

As a consequence of the way attributes are resolved lexically, a procedure remembers the full hierarchy of its lexical outer scopes as in where it is defined. We say a procedure captures its enclosing context as a closure.

Note that Đ closure is rather coarse grained compared to many other programming languages, closures elsewhere usually capture individual "variables" accessible to them when defined, while in Đ it is actually the entities behind the lexical scopes get captured.

   #} {;
    {## Coarse Grained Closure #}
    export edh'closure = bookmark()

    # Such closure semantics is designed to allow dynamic evaluation/execution of Đ snippets anywhere anytime, honoring entities being integral units of information, without individual attributes teared apart.

    # But it may lead to unintentional resource leaks, especially if you've been used to closures in other mainstream programming languages.

    # TODO demonstrate gotchas of resource leaking due to the coarse grained closure.

  }


  {## Control Flows
   # - Commonplace ones and more


   #} {;
    {## Control Flows #}
    export edh'ctrl'flows = bookmark()


    {## Pattern Matching
     # - With syntax closer to Haskell rather than Python

 Đ pattern matching syntax is closer to that of Haskell rather than Python. And unlike other languages, Đ pattern syntax is actually not hard-coded by the language grammar, it can be customized with an alternative implementation of the branch (->) operator, or even a fresh new operator functioning similarly. The pattern expression is just a regular Đ expression at left-hand-side of such an operator.

     #} {;
      edh'pattern'matching # <- follow this bookmark to detailed syntax and description in the grammar chapter
    }

  }


  {## Interpreter Procedures
   # - Natural way to eval expression in caller's scope


   #} {;
    {## Interpreter Procedures #}
    export edh'interpreter'proc = bookmark()


  }


  {## Fancy Operators
   # - Like in mathematics, symbolic notations usually come more concise


   #} {;

  }


  {## Partially Applied Procedure
   # - No currying, but `partial()` resembles that in Python

We are not currying Đ procedures, but we have `partial()` resembling that in Python.

   #} {;
    {## Partially Applied Procedure #}
    export edh'partial = bookmark()

    # %% # Take this simple procedure for example
    method f( a, b, c, ) {
      console.print( 'This is f()', a=a, b=b, c=c, )
    }

    # You can partially apply it like this
    f1 = partial ( 1, 2 ) ( f )

    # Or this more idiomatic form
    let f2 = f|partial( 1, 2 )

    # Or instead of a `let` statement, write it like this:
    f3 = ( f|partial( 1, 2 ) )
    # %# Note the pipe (|) operator has a rather low precedence -5, which is even lower than the assign (=) operator's precedence 0, so if not writing it as a `let` statement, parenthesis is necessary

    # %% #
    f1( 3 )

    # %% #
    f2( 5 )

    # %% #
    f3( 7 )

    # %#
  }


  {## Decorator
   # - Python decorator goes more general in Đ

Python decorator syntax makes application of higher order functions more ergonmic.

Inspired by Haskell, Đ introduces the procedure call ($) operator (called function application operator in Haskell), it works in places where Python decorators would, though with a little different syntax.

While it works even more generally, for utility procedures like `show()` `repr()` etc. to be used with similar syntax.

   #} {;
    {## Decorator #}
    export edh'decorator = bookmark()

    {#
     # Take a typical Python `property` decorator as example

```python

class P:

  def __init__(self, x):
    self._x = x

  @property
  def x(self):
    return self._x

  @x.setter
  def x(self, new_x):
    self._x = new_x

o = P(3)

o.x = 5

o.x

```

Written equivalently in Đ like the following:

     #}

    # %% #
    class P {

      method __init__( x as this._x ) pass

      property$
      method x() this._x

      setter$
      method x( new'x ) {
        this._x = new'x
      }

    }

    o = P(3)

    o.x = 5

    o.x

    # %#


    # %% # A decorator is usually written in the host language, but as well, it can be written in Đ the surface language, in form of an interpreter procedure

    interpreter decor( callerScope, fe ) case callerScope.eval( fe ) of { f } -> {
      callerScope.eval( expr method @(f.name) ( ***apk ) {
          console.info<| 'Calling procedure `' ++ {$ f.name $} ++ '` with: ' ++ apk
          {$ f $} ( ***apk )
      } )
    }

    # %% # And used like this

    decor$
    method g ( a, b, c ) {
      console.info<| 'This is g(), we have: ' ++ ( a=a, b=b, c=c, )
    }

    # %% # The decorated procedure can be used straight forward
    g( 1, 2, 3 )

    # %#
  }


  {## Equal vs Identical
   # - Beyond the `==` operator

 Most programming languages use the `==` operator for equality tests, there are more for the whole story.

 In Python, there is also the `is` operator for identity test, it uses memory address for major cases, with some special treatment, e.g. w.r.t. int objects.

 In JavaScript, there is also the `===` operator for uncoercing equality test, solving misfortune with the coercing `==` operator.

Identity equality and instant equality should be separately reasoned about, especially when immutable values and mutable values are both under consideration. Equality can change after objects get mutated, but many programming languages don't address this semantics enough, leaving gotchas for unworried programmers to create buggy software.

And it's actually a bit more complicated in Đ as named values (term definitions) is also involved.

   #} {;
    {## Equal vs Identical #}
    export edh'equal'vs'identical = bookmark()

    edh'equalities # <- follow this bookmark to the detailed description in the grammar chapter
  }


  {## Named Values / Term Definitions
   # - Got the familiar (:=) operator for definition
   #} {;
    edh'term'def # <- follow this bookmark to details in the grammar chapter,
    # or just run following cells to get the feel

    # %% # make sure to run this cell before the ones following it
    π := 3.14

    # %% # this prints its name, not value
    repr( π )

    # %% # after arithmetics, it is no more a term,
    repr( π * 1 ) # just an immutable numeric value

    # %% # while type of a term comes from its value
    type( π )

    # %% # and Đ knows it being a term, and can show that accordingly
    show( π )

    # %% # otherwise it's can be used just like an attribute
    r = 1.58
    C = 2 * π * r

    # %#
  }


  {## Đ Vocabulary for Nullability
   # - nil, null, None, Nothing and friends
   #} {;
    edh'nullability # <- follow this bookmark to details in the grammar chapter,
    # or just run following cells to get the feel

    # %% # `nil` will not be printed by REPL
    nil

    # %%
    type( nil ) is nil

    # %% `null()` is the null-test procedure, relatable to the `null`
    # function as in Haskell, but semantically more like:
    #  - Negated *Truth Value Testing* as in Python
    #  https://docs.python.org/3/library/stdtypes.html#truth-value-testing
    # And
    #  - *Falsy Testing* as in JavaScript
    #  https://developer.mozilla.org/en-US/docs/Glossary/Falsy
    # For a dynamic language
    null( nil )
    # %%
    null( 0 )
    # %%
    null( 1 )

    # %% # Note a procedure value will always be *truthy*
    null( null ) # recognize the result please

    # With the mechanism to define named values (i.e. terms), some named *nil* values can be defined for special purpose:

    # %%
    None
    # %%
    Nothing

    # %%
    show( None )
    # %%
    show( Nothing )

    # %%
    None == Nothing
    # %%
    None is Nothing

    # %%
    None == nil
    # %%
    None is nil

    # %%
    Nothing == nil
    # %%
    Nothing is nil

    # %#
  }

}


{## Object-Oriented, along with Simpler Values
 # - Everything is a Value (instead of Object) in Đ

Everything is an Object in Python / Smalltalk, Đ seeks to be as *Object-Oriented* as Python, but *NOT* everything is an object here, such as numbers, strings, and procedures. Also, intrinsic mutable containers, namely dict and list are not object in Đ, along with immutable containers, namely pairs and arguments packs.

 #} {;

  # The Đ Object System is an advanced topic a dedicated chapter
  import * './advanced/objs' # <- follow this import source to that chapter

  # A brief introduction lives in the grammar chapter as well, for its compositional multiple inheritance, and how both class based inheritance and prototype based inheritance are supported.
  edh'objs'inheritance # <- follow this bookmark to the details in the grammar chapter


  {## Class Based Inheritance similar to Python
   # - Class based, C3 linearized multiple inheritance, with magic methods

Except customizable meta class, Đ mimics all aspects of Python's object system, including C3 linearization w.r.t. multiple inheritance, properties, and magic methods with `NotImplemented` semantics.

   #} {;
    {## Class Based Inheritance similar to Python #}
    export edh'oo'similar'to'py = bookmark()

    edh'cls'inheritance # <- follow this bookmark to the details in the grammar chapter

    # TODO typical Python class hierarchy and the Đ translation here


    {## Data Classes
     # - Python PEP-557 (Data Classes) got dedicated syntax in Đ

Đ supports all features of Python "Data Classes", yet with the dedicated `data` keyword for syntax
  https://www.python.org/dev/peps/pep-0557

Beyond PEP-557 features, Đ data classes especially shines in pattern matching use cases, the `__match__()` magic method allows a data class to parse arbitrary values into data instances, and a pattern can extract just data fields of interest from the result, comes rather convenient.

     #} {;
      edh'data'classes # <- follow this bookmark to the details in the grammar chapter
    }


    {## Magic Methods
     # - Python equivalent ones and more


     #} {;
      {## Magic Methods #}
      export edh'magic'mths = bookmark()


      {## Applicability Semantics
       # - Resembling `NotImplemented` in Python, and more
       #} {;
        # The Đ Applicability Semantics is an advanced topic a dedicated chapter
        import * './advanced/appl' # <- follow this import source to that chapter

        {## Defaulting Values
         # - Not/Applicable is 1st class value
         #} {;
          {## Defaulting Values #}
          export edh'defaulting'values = bookmark()

          # %% # `NA` means Not/Applicable, indicating a result defaulting to `nil`, which technically can't be defaulted, so will be propagated until caught as an error condition.
          show$ NA

          # Artitrary defaulting values can be created dynamically, with an expression providing the value used for default. Such values are usually returned from operator procedures, so objects can override their behavior with magic methods, when operated by the operator, while a default implementation is provided by the operator procedure, which is effective when no magic methods present.
          # %%
          operator 0 (+*+) (lhv, rhv) {
            return default lhv ++ ' *** ' ++ rhv
          }
          # %%
          3*7 +*+ 'is a lucky number'

          # %%
          class N {
            method __init__( val as this.__repr__ ) pass
          }

          class M { extends N
            method (+*+) (other) {
              return this ++ ' --- ' ++ other
            }
          }
          # %%
          n = N(3*7)
          m = M(3*7)
          # %%
          n +*+ 'is a lucky number'
          # %%
          m +*+ 'is a lucky number'
          # %#

          # %# Applicability & defaulting semantics are advanced topics described in another chapter
          ; () => {; import * './advanced/appl' # <- navigate to there for elaboration
            edh'na'semantics # <- follow this bookmark to the specific section there
          }
        }

      }

    }

  }


  {## Prototype Based Inheritance similar to JavaScript
   # - Prototype based multiple inheritance

Đ supports prototype based inheritance like JavaScript does, and even better, multiple prototype chains work as well.

   #} {;
    {## Prototype Based Inheritance similar to JavaScript #}
    export edh'oo'similar'to'js = bookmark()

    edh'proto'inheritance # <- follow this bookmark to the details in the grammar chapter

    # TODO typical JavaScript class hierarchy and the Đ translation here

  }


  {## Beyond `this` or `self` Reference
   # - Compositional object structure

Đ follows JavaScript/Java/C++ to use `this` keyword, instead of Python's conventional `self`, however this is not just a keyword difference.

There is additionally `that` reference in Đ, it solves [Object Schizophrenia](https://en.wikipedia.org/wiki/Schizophrenia_(object-oriented_programming)) problem. As well it solves problem akin to the [Slicing problem](https://en.wikipedia.org/wiki/Object_slicing) of C++, you just need to pass `that` instead of `this` around.

Intrinsically, Đ objects are compositional instances, the structure reflects the [Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) principle, composition and inheritance are actually unified in Đ object system.

   #} {;
    {## Beyond `this` or `self` Reference #}
    export edh'compositional'objs = bookmark()

    edh'mth'binding # <- follow this bookmark to the details in the grammar chapter
  }


  {## Object Identity Made Right
   # - Objects are wrongly assumed to be identified by memory address

Check out this flaw of Python:

```python
>>> x = 101
>>> y = 101
>>> x is y
True

>>> x = 1001
>>> y = 1001
>>> x is y
False
```

There is no similar problem with Đ in the first place, as numbers are not object at all, they are immutable values identified soly by the value itself.

Further more, Đ allows an alternative identity value to be associated with an object, as its magic `__id__` attribute (which should never change identity of course).

Data classes take advantage of this mechanism, so two data instances are considered identical iif they are of the same data class, and all their data fields are identical respectively.

   #} {;

    # %% # The `id()` utility in Đ resembls that in Python, but works more correctly
    data P(x, y) pass

    origin = P(0, 0)
    id$ origin

    # %% # Under the hood, a data class assigns the magic `__id__` attribute automatically
    origin.__id__

    # %% # So identity equality test works reasonable right
    origin is P(0, 0)

    # %#
  }

}


{## Expression Values and Scope Wrapprs
 # - Here is why Đ is even More dynamic than Python

Đ fosters dynamic evaluation of any expression, anytime, anywhere.

Expression is a 1st class type of values in Đ.

A scope can be wrapped as an object, for reflective evaluation of Đ expressions, or direct attribute manipulation to be done as in that scope.

 #} {;
  edh'exprs'in'scopes # <- follow this bookmark to the details in grammar chapter

  {## The `expr` Expression
   # - Literal expressions

An arbitrary expression following the `expr` keyword will create a literal value of `ExprType`.

At the time an `expr` is defined, immediate values can be interpolated into the defined literal expression value, each immediate expression quoted within a pair of curly braces augmented with '$' will be evaluated at the `expr` definition time, and interpolated as literal values embedded in the result expression.

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark()

    # %% # It can be assigned as an attribute of current scope like any other values
    x = expr a + b * c

    type$ x
    # %# See its type

    # %% # Its textual representation is its original source text
    repr$ x

    # %# An expression created this way will have its original source reserved, to serve as its `repr`.


    # %% # To demonstrate the interpolation
    let ( a, b, c, ) = ( 3, 7, 5, )
    x' = expr a + {$ b*c $} * c

    repr$ x'
    # %# See how the expression between `{$` and `$}` is eagerly evaluated and interpolated

    # A literal value interpolated will give its `repr` in place of the original `{$ $}` segment, for `repr` of the whole literal expression value.

    # %% # Check it evaluated in the reflective way
    scope().eval( x' )

    # %# Note that `scope().eval()` is described in the next section below

  }


  {## Scope Wrappers
   # - Scopes wrapped as objects

`scope` is a class, thus an object constructor, comes with the Đ runtime.

   #} {;
    {## Scope Wrappers #}
    export edh'scope'wrappers = bookmark()


    # Without argument, everytime you call `scope()`, it creates an object wrapping the scope of the calling site.

    # %% # Let's use a hierarchy of nested procedure scopes for the demonstration
    method f() {
      # Put these into the outer procedure scope
      let ( c, d, ) = ( 2, 8, )

      # Call an ad-hoc arrow procedure to get its procedure scope wrapped, for later observation of lexical structure of scopes with that as the tip
      return ()|() => {
        # Put these into the inner procedure scope
        let ( a, b, ) = ( 7, 3, )

        # Wrap and return current scope
        return scope()
      }
    }
    s = f()
    'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()
    # %#

    # %% # Evaluate some expression in the outer scope and see how it's changed
    s.outer.eval(expr
      e = c / d
    )
    dir$ s.outer

    # %% # Evaluate some expression in the inner scope and see how it's changed
    s.eval(expr
      e = 3*a - 5*b + c - 7*d
    )
    dir$ s
    # %#


    # %% # If an object is passed as ctor argument, it creates a wrapper object for the object scope of that object
    class C pass
    o = C()
    s = scope(o)
    s.attrs()
    # %# It's empty as no attribute is defined by a bare object

    # %% # We can put some attributes into it
    s.put( a= 3, c= 7, b= 5, )
    dir$ s

    # %% # Expression evaluation works with an object scope as well
    s.eval(expr
      d = a + b / c
    )
    dir$ s
    # %#

  }


  {## Expression Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3-arg operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expression Arguments to Procedures #}
    export edh'expr'args = bookmark()

    # %%
    x' = makeExpr( a + b * c )

    repr$ x'
    # %# See its textual representation is in AST form, with rather verbose source location information, no original source text is reserved for expressions created this way

    # %% # While it can be reflectively evaluated as well
    s.eval( x' )

    # %#

  }


  {## Code as Data
   # - A runnable piece of Đ code is just data from the perspective of the host language/runtime

Đ host procedures (written in Haskell) see Đ AST directly.

TODO expand this section.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark()
  }

}


{## Iteration & Narration
 # - Different ways to express the program's job doing


 #} {;
  {## Iteration & Narration #}
  export edh'iter'narr = bookmark()


}


{## Effect Tracking
 # - Tracking effects like Haskell does, but dynamically and the procedural way


 #} {;
  {## Effect Tracking #}
  export edh'eff'tracking = bookmark()


}
