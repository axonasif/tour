{## Đ Compared to Similar Languages #}

{## Đ Compared to Similar Languages #}
export edh'lang'cmp'details = bookmark()


{## Target Audience
 # - For developers familiar with some other Object-Oriented, dynamic scripting language

If you are familiar with any other Object-Oriented, dynamic, scripting language, like Python, JavaScript, Smalltalk etc, this is for you. You just need to know the differences and a few important gotchas, could save you a great deal of time going over some basic concepts.

Familiarity with Haskell is a great plus, as the base Đ interpreter is written in Haskell, and many Đ language constructs are influenced by Haskell.

 #} {;
  {## Target Audience #}
  export edh'lang'cmp'audience = bookmark()

  # But if you don't know another Object-Oriented dynamic scripting language, some jargons here might not click for you, then please read the chapter of Đ grammar instead
  import * './grammar'
  edh'grammar'details # <- follow this bookmark to there

  # Alternatively, you can learn Python first if you prefer.
}


{## Overview
 # - General reason of most design choices

The Đ grammar is designed with a major goal of interoperation by scripting, for IPC (Inter-Process Communication) across processes of heterogeneous runtime implementations. So as to finally integrate massive scale of software compoonents (possibly independently developed by many vendors) into live systems.

While some constructs from Haskell, Go, Python and others, are introduced
for purpose of ergonomics. E.g.

- custom infix operators, with arbitrary associativity and precedence
    * from Haskell, C++ etc.

- pattern matching & branching
    * from typical FP languages, as well as upcoming PEP-634 of Python

- goroutine
    * from Go

- compositional object
    * sorta from Go type embedding, and C++ multiple-inheritance

- class based inheritance
    * from Python, Smalltalk etc.

- C3 linearized multiple inheritance
    * from Python, which is in turn from Dylan

- magic object methods
    * from Python

- data classes
    * from Python PEP-557

- prototype based inheritance
    * from JavaScript

- fat-arrow procedure (lambda)
    * from JavaScript, while the lambda aspect from all multi-paradigm languages with FP in mind, including JavaScript and Python

- symbols
    * from JavaScript, yet much enhanced

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


{## Format-on-Save
 # - There is an official code formatter for Đ

You may already know what an opinionated code formatter is, such as Black for Python, Prettier for JavaScript (and HTML, CSS etc.), an Ormolu for Haskell:
  https://black.readthedocs.io
  https://prettier.io
  https://github.com/tweag/ormolu

So it should be no surprise to you, that Đ comes with its own formatter, yet officially:
  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

And note that Đ formatter is by default invoked on saving of `.edh` source files, Go tooling works this way, while other mainstream languages don't.

 #} {;

  # Home page of the formatter should have described the rules and your rights (freedom) well,  after modification, save or right-click to select "Format Document", then you'll see what the formatter thinks.

  # Hint: With VSCode, the default shortcut key for "Format Document", on macOS is Shift+Option+F and Ctrl+Shift+I on Linux

  # %% # try play with this cell:
  #    add/remove spaces, break it into multip lines, you name it
  1+ ( 2 - 3 ) *5 /9
  # %#

  # TODO any gotcha to be showcased here?

  # For why Đ chose curly braces over indentation rules like Python, see:
  edh'sps'insensitivity

}


{## Optional Semicolons and Commas
 # - Semicolons and commas are technically optional

Just examples ought to be enough, plus guidelines for idiomatics:

 * Avoid semicolons - unless for disambiguation
 * Place trailing commas where possible - unless it's more concise without it

Note semicolons can be really technically omitted in Đ, not the case like in JavaScript, that the language does [Automatic Semicolon Insertion]
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

 #} {;

  # The following 5 cells have identical semantics and result value
  # %%
  { a=5; b=3; c=9; }
  # %%
  {; a=5 b=3 c=9 } # <- idiomatic one
  # %%
  { a=5 b=3; c=9 }
  # %%
  { a=5 b=3 c=9; }
  # %%
  { a=5 b=3 c=9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
  # %%
  {, 'a': 5 'b': 3 'c': 9 }
  # %%
  { 'a': 5 'b': 3, 'c': 9 }
  # %%
  { 'a': 5 'b': 3 'c': 9, }
  # %%
  { 'a': 5 'b': 3 'c': 9 }
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; [ 5, 3, 9, ] # <- idiomatic one
  # %%
  ; [, 5 3 9 ]
  # %%
  ; [ 5 3, 9 ]
  # %%
  ; [ 5 3 9, ]
  # %%
  ; [ 5 3 9 ]
  # %#

  # The following 5 cells too, have identical semantics and result value
  # %%
  ; ( 5, 3, 9, ) # <- idiomatic one
  # %%
  ; (, 5 3 9 )
  # %%
  ; ( 5 3, 9 )
  # %%
  ; ( 5 3 9, )
  # %%
  ; ( 5 3 9 )
  # %#


  {## Cases Disambiguation Needed
   # - However, you'd better be reminded of necessary disambiguations
   #} {;

    {## Disambiguate Unintended Indexing / Calling #}
    export edh'disambig'idx'call = bookmark()

    # Noticed the semicolons before each pair of square/round brackets? Why are they there?

    # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


    {## Disambiguate Block from Dict #}
    export edh'disambig'blk'dict = bookmark()

    # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

    # %% # Well, check out this:
    type( {; } )
    # %% # Then this:
    type( {} )
    # %#

    # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

    # FYI, in Đ, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exception of branches' early break, though, and about that later)
    # %% # And an empty block evals to `nil`, check this to be true
    {; } is nil
    # %#

    # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
    # %% # This is a block with a single assignment expression statement
    { a=1 }
    # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
    {; a=1 }
    # %#

    # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when there are risks for it to be mis-interpreted/parsed as a dict literal:
    {;
      # It can still parse as dict literal with comments inside
    }


    # Finally, a comma to disambiguate ArgsPack (a super type of tuple like in Python), from parenthese-quoted single expression
    # %% # A single arguments pack
    ; ( 3*7, )
    # %% # A parenthese-quoted expression
    ; ( 3*7 )
    # %%
    ; type( ( 3*7, ) )
    # %%
    ; type( ( 3*7 ) )
    # %#

  }

}


{## Recommended Line Length
 # - It is under your control, well some advice here

For the record, Đ langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

 #} {;
  # %%
  '''
                                                                    80 columns ▽
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns △
'''
  # %#
}


{## Common Parts with Pervasive Languages
 # - Đ has good interoperability with Python/JavaScript etc. at source level

Đ shares some common syntax with many popular programming languages (e.g. Python, JavaScript), in a nutshell:

 * Parentheses pair is the call-making operator
 * Expressions consist of named references, joined together by prefix/infix/postfix operators with certain precedence and fixity/associativity
 * Parentheses for precedence override

 #} {;

  {## Common Syntax
   # - Đ syntax common to many popular languages
   #} {;
    {## Đ Common Syntax #}
    export edh'common'syntax = bookmark()

    # `console` hooks to the interpreter program's stdio
    # `console.print()` does exactly what you think it should
    # %%
    console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )
    # %#

    # As a code cell is run by a REPL, the result of evaluation will be printed,
    # so you don't really need `console.print()` that often
    # %%
    1 + 2 - 3 * 7
    # %#

    # When precedence rule doesn't work outright, parenthese comes to rescue
    # %%
    1 + ( 2 - 3 ) * 7
    # %#
  }


  {## Module System
   # - Blend of several popular things
   #} {;
    {## Module System #}
    export edh'modu'system = bookmark()

    {## Node.js Package Directory Hierarchy
     # - Directory layout for package deployment

  https://nodejs.org/api/modules.html

But you use `epm` to initialize EPM homes, install / update / remove pakcages in each home manually, instead of the full-automatic `npm` tool.

  https://github.com/e-wrks/epm

     #} {;
      {## Node.js Package Directory Hierarchy #}
      export edh'pkg'layout = bookmark()
    }


    {## ES6 import/export Syntax
     # - Dedicated `import` and `export` keyword

  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules

You use explicit `export` keyword to decorate artifact definitions (e.g. assignments, procedure/class declarations), for them to be importable by other modules (or objects).

The `import` keyword is used to denote an import expression, the expression evaluates to the object resolved as the source for import, and with a side effect of artifacts exported from that object to be received into current scope, however specified by the arguments receiver part of the import expression.

     #} {;
      {## ES6 import/export Syntax #}
      export edh'imp'exp'syntax = bookmark()

      # Note that the import/export mechanism works with any object in Đ, module objects as well
      edh'imp'exp # <- follow this bookmark to the section describing the detailed syntax and semantics in the grammar chapter

    }


    {## Python Module File Naming Convention
     # - Special module files like `__init__.edh` and `__main__.edh`

  https://docs.python.org/3/tutorial/modules.html

Đ module files ends with `.edh` extension name, special cases include:

 * `__init__.edh` can stand for the import target as its parent directory, relative imports within it work more intuitively than a file module with its parent folder's name plus the `.edh` suffix.

 * `__main__.edh` stands for the entry module source file, when its parent directory is resolved as the entry module of an interpreter process.

Note that `__main__.edh` is the only valid entry module file name, unlike Python, otherwise named module file will never be run as an entry module.

     #} {;
      {## Python Module File Naming Convention #}
      export bookmark'identifier = bookmark()
    }


    {## Python Module Semantics
     # - Strict loading and meta artifacts

The module loading semantics is similar to Python, every statements at top levels will be strictly executed in a sequence. The cyclic importing (with possibly multiple levels of indirections) cases are also similar to those in Python.

     #} {;
      {## Python Module Semantics #}
      export edh'modu'loading'meta'arts = bookmark()

      edh'modu'load'cyc # <- follow this bookmark for detailed describption of loading semantics, including cyclic loading cases


      {## Reflective Attributes in a Module
       # - Every module object contains some meta attribute to reflect its source information
       #} {;

        # %% # It should at lease contain the `__name__` attribute, similar to Python
        __name__

        # %% # File modules should contain `__file__` for absolute file path of the source file as well, similar to Python
        __file__

        # %% # Also `__path__` to be used as basis for relative import from within the very module, this is beyond Python
        __path__

        # %#
      }

    }

  }


  {## Minor but Subtle/Surprising Differences
   # - You might be surprised by a few things though
   #} {;

    {## String Literals
     # - Almost all possible forms are valid here

In an era without code syntax highlighting, multi-line strings can be adversely confusing, but nowadays no text editor can claim itself being a code editor without proper syntax highlighting. So Đ allows a string literal to span multi lines anyway, dunno if this can trip someone up, but be aware.

     #} {;
      {## String Literals #}
      export edh'str'literals = bookmark()

      # %%
      'single-quote, single-line string'
      # %%
      'single-quote,
multi-line string'
      # %%
      "double-quote, single-line string"
      # %%
      "double-quote,
multi-line string"
      # %%
      `tick-quote, single-line string`
      # %%
      `tick-quote,
multi-line string`
      # %%
      '''triple-single-quote, single-line string'''
      # %%
      '''triple-single-quote,
multi-line string'''
      # %%
      """triple-double-quote, single-line string"""
      # %%
      """triple-double-quote,
multi-line string"""
      # %%
      ```triple-tick-quote, single-line string```
      # %%
      ```triple-tick-quote,
multi-line string```

      {## Trailing Spaces in Multi-line String Literal
       # - It'll be removed by Đ code formatter

One particar note for multi-line strings, though:
  ALL TRAILING SPACES will be REMOVED by Đ code formatter
That includes such spaces inside a multi-line string literal, you need a workaround just in case.

       #} {;
        {## Trailing Spaces in Multi-line String Literal #}
        export edh'fmt'rm'trail'spc'in'str'lit = bookmark()

        # %%
        """You'll need tricks like   """ +
        """this to preserve space(s), which otherwise,
will be at the end of a source line."""
        # %#
      }
    }

    {## Rational Decimal Numbers
     # - Don't take floating point numbers for granted

Floating point arithmetic is intrinsic to numbers represented natively in most computer programming languages of today, see:

> What Every Programmer Should Know About Floating-Point Arithmetic
  https://floating-point-gui.de/

Python `float` and JavaScript `number` are all subject to those gotchas.

     #} {;
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You get it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      edh'rat'decimal # <- follow this bookmark to the detailed section in the grammar chapter

      # Takeaway is:
      #   Numbers in Đ are lossless (to the extent of rational numbers)
      # Well please keep in mind that comes at a rather high cost, both spacial and time complexity are much higher to work with numbers in Đ, than in other languages.

      # The overhead is justified for ergonomics concerns where human errors can be disastrous, and raw machine performance should be pursued by perfessionals and by meaning means, such as the approach of `hasdim` you'll see at:
      import * 'dim/tour' into Nothing
    }


    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn

The single quote character (') can appear in an identifier, only if it's not the first character.

     #} {;

      # %% # In Haskell and Math, a suffix ' is used to denote something slightly different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' + q' + ' equal to ' + q + " ? That's " + ( q'==q ) + ' of course!'
      # %#

      # There are norms in Haskell for two or even more ' as the suffix, and technically it can appear anywhere except being the start of an identifier, it's the same in Đ

      {## An Unnamed Naming Convention
       # - Or do you know its name?

About naming conventions, quoting:
  http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.

       #} {;

        # %% # In Đ more usages of ' can be seen, such as word delimiters in a long identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!DecimalType
        number'of'people = 5
        # %# Note about (::) and (!), they are annotation operators in Đ, will be explained later

      }
    }
  }

}


{## Terminology Differences
 # - Some similar things are named differently
 #} {;

  {## Procedure instead of Function
   # - There are procedures, but no function

A *function* in mathematics has well defined input and output, it can refer to nothing outside of its immutable input (though with enclosed implicit parameters included). Functional programming langauges e.g. Haskell, reflects such constraint well. But unfortunately many procedural / imperative programming langauges, tracing back to C and other ancestors, defined their "function"s with ability to access mutable global / closure "variable"s (The "variable" there is albeit another misconception agsinst mathematical variables), so side-effects can be there out of trivial reasonability by programmers in the day, leading to more bugs in software developed comercially.

It's not a big deal for Đ the language to have stopped refering to impure computations (with side-effects and mutable input) as "function"s, but more conforming conception is a good start to put effect tracking as a focus for the programming tools, looking forward for greater quality in the software developed as the result.

   #} {;
    {## Procedure instead of Function #}
    export edh'term'proc'stead'func = bookmark()
  }


  {## Attribute instead of Variable
   # - There are attributes, but no variable

There is no such a concept/term of "variable" in Đ. The "variable" concept in conventional programming languages is misleading or conflicting when you could possibly have mathematical concepts in the domain model of your business. More properly it should be called "assignable" as suggested in:
  https://existentialtype.wordpress.com/2013/07/22/there-is-such-a-thing-as-a-declarative-language

Although attributes of entities in Đ are inherently meant to be assigned (as well as to be observed), they can not stand alone without a backing entity. Unlike in conventional programming languages, where a "variable" can be assigned individually.

   #} {;
    {## Attribute instead of Variable #}
    export edh'term'attr'stead'var = bookmark()
  }

}


{## Lexical Structure & Closure
 # - Similar to Python, JavaScript and etc.

Đ source code is organized as modules with respective source files, exporting artifacts for reuse, while importing artifacts from others, quite similar to Python codebases or JavaScript codebases consisting of ES6 modules.

Closure in Đ is more coarse grained - entire scopes, instead of individual "variable"s are enclosed. It makes Đ programs more potent to resource leaks, so more care should be taken by the programmer, to clear references to resource values as soon as not needed anymore.

 #} {;
  {## Lexical Structure & Closure #}
  export edh'lexi'struct'clo = bookmark()

  {## Name / Identifier
   # - The so called *variable identifier* or *variable name* elsewhere

All data in an Đ world is stored as attributes associated with certain entities under some names. Both objects and scopes are backed by entities, the naming mechnism works at the entity level, so stays the same for both objects and scopes.

   #} {;
    {## Name / Identifier #}
    export edh'name'identifer = bookmark()

    {## Usual, Alphanumeric Names
     # - Just like how *variable*s can be named in other programming languages such as Python
     #} {;

      # Most programming languages allow only alphanumeric strings as "variable" identifiers, with limited choices of special characters (such as the usual underscore (`_`), and `$` in Java)

      # Đ allows underscore (_) and the single-quote character (') in alphanumeric names, this is following Haskell, and more scientific naming friendly.

      edh'alphanum'names # <- follow this bookmark to the detailed secion in the grammar chapter

    }


    {## Symbolic Names
     # - Cross component encapsulation of implementation details

JavaScript introduced symbol, which is allowed as identifier of object properties:
  https://developer.mozilla.org/en-US/docs/Glossary/Symbol

Đ takes this idea further, gives it bigger purpose, and dedicated syntax.

Like other dynamic programming languages such as Python, JavaScript, Đ objects (and scopes) are openly accessible, but with symbol key values eligible as symbolic attribute names, Đ programming interfaces can have multiple level of encapsulation ability, that even more flexible than what's supported by Java, C++ and similar languages.

Java has private/protected/public and the implicit package qualification to limit access to fields of a class, C++ has private/protected/public qualification plus friend declarations. In Đ, you define symbols to be used as the name of such fields (attributes of objects / scopes), then you can export the symbol key values differently than how the class (or namespace etc.) is exported. Other components can import these keys and use them to access such symbolic fields, as if they are public, or those fields will appear private/hidden to them. Different contracts with different sets of available symbols can be defined and exposed to different parties, for different levels of knowledge & access to the same codebase of implementation details.

     #} {;

      edh'symbolic'names # <- follow this bookmark to the detailed description of symbolic names and at-notations in the grammar chapter


      # %% # The `symbol` keyword is used to define new symbol keys
      symbol @secret'stuff

      # %% # Directly assign to symbolic attribute into current scope
      ; @secret'stuff = 'a bit of mysterious'

      # %% # Directly obtain a symbolic attribute from current scope
      ; @secret'stuff

      # %% # The at-notation works as argument name, as well as attribute name in dot-notation
      namespace shared'ns ( @secret'stuff= 'This is public to whoever knows the key', ) {

        # Assign symbolic object attribute with dot-notation
        this.@secret'stuff ++= ", but private to ones don't."

      }

      # %% # Obtain symbolic object attribute value via dot-notation
      shared'ns.@secret'stuff

      # %#
    }


    {## Quaint Names
     # - Technically, any text can be used as attribute name

Special characters don't get in the way for you to use strings containing them as attribute identifiers. This comes handy in some cases, e.g. LSP (Language Server Protocol) service names tend to have slash `/` characters in it, but the Đ language server defines such service methods with verbatimly such names in the code.

     #} {;

      edh'quaint'names # <- follow this bookmark to the detailed section in the grammar chapter

      # %% # Assign an attribute with a dash in its name
      shared'ns.@'full-time' = true

      # %% # Obtain such an attribute
      shared'ns.@'full-time'

      # %% # Check all attributes there
      dir$ shared'ns

      # %#
    }

  }


  {## Scopes, Entities, and Attributes
   # - No variable, only entities with attributes backing scopes
   #} {;

    # There is not such a thing called variable in Đ ...
    edh'term'attr'stead'var


  }


  {## Modules
   # - Similar to Python Modules

Each `.edh` file is an Đ module

   #} {;
    {## Modules #}
    export edh'modules = bookmark()


  }


  {## Namespaces
   # - Similar to TypeScript namespace

An Đ namespace is a special object defined with dedicated syntax

Namespaces are important in Đ, as alternative solutions to certain problems solved differently in other languages.

   #} {;
    {## Namespaces #}
    export edh'namespaces = bookmark()

    # Alternative to Python nonlocal semantics

    # Alternative to JavaScript hoisting, - for a piece of code in need of calling a later defined procedure, wrap it in a method procedure of the ns, defined earlier

  }


  {## Scoped Blocks
   # - A usual block doesn't create a scope, but there is special syntax
   #} {;
    {## Scoped Blocks #}
    export edh'scoped'blocks = bookmark()


  }


  {## Lexical Scoping Rules
   # - Close to that of Python/JavaScript, yet with subtle difference

   #} {;
    {## Lexical Scoping Rules #}
    export edh'lexi'rules = bookmark()

    edh'lexi'scoping # <- follow this bookmark to the detailed rules in the grammar chapter

    {## Attribute Reading
     # - An attribue can be addressed off any scope enclosing the access point

The resolution is from inner-most scope to outer-most scope (which is the world root namespace), which ever matched by attribute key becomes the resolution result

     #} {;
      {## Attribute Reading #}
      export edh'attr'read = bookmark()


    }


    {## Attribute Writing
     # - Direct assignment always update the inner-most current scope

There is no way to directly write to any scope other than current scope in context

     #} {;
      {## Attribute Writing #}
      export edh'attr'write = bookmark()


    }


    {## Attribute Deletion
     # - Instead of Python's `del` statement and JavaScript's `delete` operator, assignment with `nil` does the trick in Đ


     #} {;
      {## Attribute Deletion #}
      export edh'deletion = bookmark()

    }

    {## Closures
     # - Closures are way more coarse grained in Đ

A closure/procedure captures the full lexical scope hierarchy at the point it is defined.

     #} {;
      {## Closures #}
      export edh'closures = bookmark()


      {## Compared to Python `nonlocal` Variables
       # - Đ is more dynamic than Python

Đ attribute access

       #} {;
        {## Compared to Python `nonlocal` Variables #}
        export edh'more'dyn'than'py'nonlocal = bookmark()


      }

    }

  }

}


{## Pattern Matching
 # - A concise way to organize arbitrary number of control branches

 #} {;
  {## Pattern Matching #}
  export edh'pattern'matching = bookmark()


  {## Guard Conditions
   # - Guard a match with certain conditions


   #} {;
    {## Guard Conditions #}
    export edh'pattern'guard = bookmark()


  }

}


{## Object-Oriented, but Not Entirely
 # - Everything is a Value (instead of Object) in Đ

Everything is an Object in Python / Smalltalk, but although Đ is as *Object-Oriented* as Python, *NOT* everything is an object here, such as numbers, strings, and procedures. And there are a handful of special values.

Đ implements an object system with compositional Multiple-Inheritance with Multiple-Prototype Chains.

 #} {; import * './advanced/objs' # <- navigate to elaboration of Đ Object System

  {## Data Classes
   # - Python PEP-557 (Data Classes) got dedicated syntax in Đ

Beyond PEP-557 features in a dedicated syntax, Đ data classes especially shines in pattern matching use cases, closely mimics ADT, predating PEP-634 (which is upcoming in Python 3.10).

   #} {;
    {## Data Classes #}
    export edh'data'classes = bookmark()


  }


  {## Beyond `this` Reference
   # - Compositional object structure

Đ follows JavaScript/Java/C++ to use `this` keyword, instead of Python's `self`, however this is not a simple choice end here.


`that` reference solves a problem akin to the slicing problem of C++
  https://en.wikipedia.org/wiki/Object_slicing


   #} {;
    {## Beyond `this` Reference #}
    export edh'compositional'objs = bookmark()


  }


  {## Identity Test Corrected
   # - Object identity has some flaws, value semantics can fix that


   #} {;

  }


  {## Modules and Namespaces are Objects
   # - There are builtin classes for module and namespace respectively


   #} {;
    {## Modules and Namespaces are Objects #}
    export edh'modu'ns'be'obj = bookmark()


  }

}


{## Notable Aspects of Đ Value System
 # - Everything is a value in Đ, something is different
 #} {; import * './advanced/vals'

  {## Named Values / Term Definitions
   # - Got the familiar (:=) operator for definition
   #} { edh'term'def # <- follow this bookmark to learn more details or just run following cells to get some feel

    # %% # make sure to run this cell before the ones following it
    π := 3.14

    # %% # this prints its name, not value
    repr( π )

    # %% # after arithmetics, it is no more a term,
    repr( π * 1 ) # just an immutable numeric value

    # %% # while type of a term comes from its value
    type( π )

    # %% # and Đ knows it being a term, and can show that accordingly
    show( π )

    # %% # otherwise it's can be used just like an attribute
    r = 1.58
    C = 2 * π * r

    # %#
  }


  {## Đ Vocabulary for Nullability
   # - nil, null, None, Nothing and friends
   #} { edh'nullability # <- follow this bookmark to learn more details
    # or just run following cells to get some feel

    # %% # `nil` will not be printed by REPL
    nil

    # %%
    type( nil ) is nil

    # %% `null()` is the null-test procedure, relatable to the `null`
    # function as in Haskell, but semantically more like:
    #  - Negated *Truth Value Testing* as in Python
    #  https://docs.python.org/3/library/stdtypes.html#truth-value-testing
    # And
    #  - *Falsy Testing* as in JavaScript
    #  https://developer.mozilla.org/en-US/docs/Glossary/Falsy
    # For a dynamic language
    null( nil )
    # %%
    null( 0 )
    # %%
    null( 1 )

    # %% # Note a procedure value will always be *truthy*
    null( null ) # recognize the result please

    # With the mechanism to define named values (i.e. terms), some named *nil* values can be defined for special purpose:

    # %%
    None
    # %%
    Nothing

    # %%
    show( None )
    # %%
    show( Nothing )

    # %%
    None == Nothing
    # %%
    None is Nothing

    # %%
    None == nil
    # %%
    None is nil

    # %%
    Nothing == nil
    # %%
    Nothing is nil

    # %#
  }


  {## Applicability Semantics
   # - We talk about the lack thereof, actually
   #} { import * './advanced/appl' # <- navigate to elaboration of Đ Applicability Semantics

    edh'na'semantics # <- follow this bookmark to learn more details

    # %% # NA stands for Not/Applicable, it's a literal constant in Đ
    NA

    # %% # How is it technically working?
    show( NA )

    # %% # The actually `NA` value is a defined constant term, with the value in turn being a *default* expression of literal `nil`, so it is technically a shorthand of `NA := default nil`
    default nil
    # %#

    # More about *default* expressions later, but you just see its repr now for some intuition
  }


  {## Expression Values and Scope Wrapprs
   # - Here is why Đ is even More dynamic than Python
   #} {;
    {## Expression Values and Scope Wrappers #}
    export edh'exprs = bookmark()

    {## Scope Wrappers
     # - A scope can be wrapped as an object to do reflection in Đ

`scope` is a builtin class.

     #} {;
      {## Scope Wrappers #}
      export edh'scope'wrappers = bookmark()

      # %% # without argument, it creates an object wrapping the scope where it's called from
      method f() {
        method g() {
          let ( a, b, ) = ( 7, 3, )
          scope()
        }
        let ( c, d, ) = ( 2, 8, )
        return g() @=> g = nil # dispose g after one-time used
      }
      s = f()
      'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()

      # %% # if an object is passed as ctor argument, it creates an object wrapping that object's scope
      class C pass
      o = C()
      s = scope(o)
      s.put( a= 3, c= 2, b= 5, )
      s.attrs()

      # %#
    }


    {## The `expr` Expression
     # - Lambda without formal argument declaration

A procedure is always called against some object, it also has a formal declaration of its arguments, what if we strip off these properties? The result is: we get expressions.

Expression is 1st class in Đ, you can create expression values with literal form

     #} {;
      {## The `expr` Expression #}
      export edh'expr'expr = bookmark()

      # %%
      x = expr a + b * c

      # %#

    }


    {## Expression Arguments to Procedures
     # - Arguments are passed in expr form, to interpreter procedures and 3af operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

     #} {;
      {## Expression Arguments to Procedures #}
      export edh'expr'args = bookmark()

      # %%
      x' = makeExpr( a + b * c )
      # %%
      s.eval( x' )
      # %#

    }


    {## Code as Data
     # - A runnable piece of Đ code is just data from the perspective of the host language/runtime

Đ host procedures (written in Haskell) see Đ AST directly.

     #} {;
      {## Code as Data #}
      export edh'host'proc'exprs = bookmark()


    }

  }

}


{## Fancy Operators
 # - Like in mathematics, symbolic notations usually come more concise
 #} {;
  {## Đ Operators #}
  export edh'operators = bookmark()

  {## Call Making
   # - Beyond parentheses as the call-operator
   #} {;
    {## Call Making #}
    export edh'call'making'op = bookmark()


    # %%
    console.print$ 'The low-precedence, procedure-call operator `($)` '
    ++ 'can be used for a little stranger syntax.'

    # %% May be even more strange
    show$ ($)
    # %#
    # Run above cell, you should see:
    #  intrinsic: infixr -5 ($)

    # You'd feel familiar if you know about Haskell, `$` is a right-associative, infix operator, of precedence -5 (which is rather low) in Đ (not the core language, but a custom operator from the default batteries technically). The semantics/behavior of ($) is procedure-call in Đ, rather like ($) as the function-application operator in Haskell.

    # To address an operator, you quote it with a pair of parentheses just like in Haskell, so `show$ ($)` should be interpreted as calling procedure `show` with the value of ($) operator procedure (which is first class value in Đ) as the only argument.

    # %% For better understanding, it can be written like this, which is more usual
    op = ($)
    show( op )

    # %%
    console.print$ 'Though the (+) operator works to concatenate strings for'
    + ' Python interoperability, the (++) operator is more idiomatic in Đ'
    ++ ' for string concatenation, resembling Haskell.'

    ; # As you have learned, a semicolon is usually necessary before a starting parentheses, to disambiguate from procedure-call-making, which binds the tightest
    # %% # The pipe operator (|) is flipped ($) operator
    ($) |show
    # %% # This is equivalent to:
    show$ ($)
    # %% # Checkout what the (|) operator is
    show$ (|)
    # %#

    # Note the (|) operator resembles UNIX pipe, while its semantics is more close to the (&) operator in Haskell, which is flipped ($) operator.

  }

  {## Exception Handling
   # - Operators + Pattern Matching, instead of `try/catch/finally`

   #} {;
    {## Exception Handling #}
    export edh'exc'hndl'op = bookmark()


  }

  {## Other Interesting Operators
   # - Misc
   #} {;
    {## Other Interesting Operators #}
    export edh'misc'ops = bookmark()

    # Some other operators of interest:

    # %%
    show$ (::)
    # %%
    show$ (!)

    # %#
  }

}


{## More or Less Functional than You'd Expect
 # - Roots in Haskell, Go, Python, and JavaScript


 #} {;
}
