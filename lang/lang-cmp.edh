{## Đ Compared to Similar Languages #}

{## Đ Compared to Similar Languages #}
export edh'lang'cmp'details = bookmark()


{## Target Audience
 # - For developers familiar with some other Object-Oriented, dynamic scripting language

If you are familiar with any other Object-Oriented, dynamic, scripting language, like Python, JavaScript, Smalltalk etc, this is for you. You just need to know the differences and a few important gotchas, could save you a great deal of time going over some basic concepts.

Familiarity with Haskell is a great plus, as the base Đ interpreter is written in Haskell, and many Đ language constructs are influenced by Haskell.

 #} {;
  {## Target Audience #}
  export edh'lang'cmp'audience = bookmark()

  # But if you don't know another Object-Oriented dynamic scripting language, some jargons here might not click for you, then please read the chapter of Đ grammar instead
  import * './grammar'
  edh'grammar'details # <- follow this bookmark to there

  # Alternatively, you can learn Python/JavaScript first if you prefer.
}


{## Overview
 # - General reason of most design choices

The Đ grammar is designed with a major goal of interoperation by scripting, for IPC (Inter-Process Communication) across processes of heterogeneous runtime implementations. So as to finally integrate massive scale of software compoonents (possibly independently developed by many vendors) into live systems.

Đ tries to be syntatically compatible with JavaScript as much as possible, many JavaScript code snippets are valid Đ code in syntax (and even with similar semantics at times), together with Đ's expression interpolation feature, JavaScript code snippets can be defined with legitimate Đ `expr` expressions, with runtime values "interpolated" into them, then sent to the Browser or NodeJS servers for execution. Many Python snippets can be crafted and remotely executed in similar ways, when indentations & curly braces don't stay in the way.

While some constructs from Haskell, Go, Python and others, are introduced into Đ for purpose of ergonomics. E.g.

- custom infix operators, with arbitrary associativity and precedence
    * from Haskell, C++ etc.

- pattern matching & branching
    * from typical FP languages, as well as upcoming PEP-634 of Python

- goroutine
    * from Go

- compositional object
    * sorta from Go type embedding, and C++ multiple-inheritance

- class based inheritance
    * from Python, Smalltalk etc.

- C3 linearized multiple inheritance
    * from Python, which is in turn from Dylan

- magic object methods
    * from Python

- data classes
    * from Python PEP-557

- prototype based inheritance
    * from JavaScript

- fat-arrow procedure (lambda)
    * from JavaScript, while the lambda aspect from all multi-paradigm languages with FP in mind, including JavaScript and Python

- symbols
    * from JavaScript, yet much enhanced

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


{## Format-on-Save
 # - There is an official code formatter for Đ

You may already know what an opinionated code formatter is, such as Black for Python, Prettier for JavaScript (and HTML, CSS etc.), an Ormolu for Haskell:
  https://black.readthedocs.io
  https://prettier.io
  https://github.com/tweag/ormolu

So it should be no surprise to you, that Đ comes with its own formatter, yet officially:
  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

And note that Đ formatter is by default invoked on saving of `.edh` source files, Go tooling works this way, while other mainstream languages don't.

 #} {;

  # Home page of the formatter should have described the rules and your rights (freedom) well,  after modification, save or right-click to select "Format Document", then you'll see what the formatter thinks.

  # Hint: With VSCode, the default shortcut key for "Format Document", on macOS is Shift+Option+F and Ctrl+Shift+I on Linux

  # %% # try play with this cell:
  #    add/remove spaces, break it into multip lines, you name it
  1+ ( 2 - 3 ) *5 /9
  # %#

  # TODO any gotcha to be showcased here?

  # For why Đ chose curly braces over indentation rules like Python, see:
  edh'sps'insensitivity

}


{## Optional Semicolons and Commas
 # - Semicolons and commas are technically optional

Just examples ought to be enough, plus guidelines for idiomatics:

 * Avoid semicolons - unless for disambiguation
 * Place trailing commas where possible - unless it's more concise without it, e.g. there're only 3 terms or less, and you know that no new terms tend to be added following the last one.

Note semicolons can be really technically omitted in Đ, not the case like in JavaScript, that the language does [Automatic Semicolon Insertion]
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

 #} {;

  # One-liner code block
  # - The following 5 cells have identical semantics and result value
  # %%
  { a=5; b=3; c=9; }
  # %%
  {; a=5 b=3 c=9 } # <- idiomatic one
  # %%
  { a=5 b=3; c=9 }
  # %%
  { a=5 b=3 c=9; }
  # %%
  { a=5 b=3 c=9 }
  # %#

  # Dict literal
  # - The following 5 cells too, have identical semantics and result value
  # %%
  { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
  # %%
  {, 'a': 5 'b': 3 'c': 9 }
  # %%
  { 'a': 5 'b': 3, 'c': 9 }
  # %%
  { 'a': 5 'b': 3 'c': 9, }
  # %%
  { 'a': 5 'b': 3 'c': 9 }
  # %#

  # List literal
  # - The following 5 cells too, have identical semantics and result value
  # %%
  ; [ 5, 3, 9, ] # <- idiomatic one
  # %%
  ; [, 5 3 9 ]
  # %%
  ; [ 5 3, 9 ]
  # %%
  ; [ 5 3 9, ]
  # %%
  ; [ 5 3 9 ]
  # %#

  # Positional-only args pack literal
  # - The following 5 cells too, have identical semantics and result value
  # %%
  ; ( 5, 3, 9, ) # <- idiomatic one
  # %%
  ; (, 5 3 9 )
  # %%
  ; ( 5 3, 9 )
  # %%
  ; ( 5 3 9, )
  # %%
  ; ( 5 3 9 )
  # %#


  {## Cases Disambiguation Needed
   # - However, you'd better be reminded of necessary disambiguations
   #} {;

    {## Disambiguate Unintended Indexing / Calling #}
    export edh'disambig'idx'call = bookmark()

    # Noticed the semicolons before each pair of square/round brackets? Why are they there?

    # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


    {## Disambiguate Block from Dict #}
    export edh'disambig'blk'dict = bookmark()

    # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

    # %% # Well, check out this:
    type( {;} )
    # %% # Then this:
    type( {} )
    # %#

    # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

    # FYI, in Đ, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed. Tthough there are exceptional cases like early `return`, `break`, `continue`, and (->) branches, but about that later.
    # %% # And an empty block evals to `nil`, check this to be true
    {;} is nil
    # %#

    # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
    # %% # This is a block with a single assignment expression statement
    { a=1 }
    # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
    {; a=1 }
    # %#

    # The idiomatic style is to put a semicolon right after the opening brace (curly bracket), when there are risks for it to be mis-interpreted/parsed as a dict literal:
    {;
      # It can still parse as dict literal with comments inside, if not disambiguated
    }


    # Finally, a comma to disambiguate ArgsPack (a super type of tuple like in Python), from parenthese-quoted single expression
    # %% # A single arguments pack
    ; ( 3*7, )
    # %% # A parenthese-quoted expression
    ; ( 3*7 )
    # %%
    ; type( ( 3*7, ) )
    # %%
    ; type( ( 3*7 ) )
    # %#

  }

}


{## Recommended Line Length
 # - It is under your control, well some advice here

For the record, Đ langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

 #} {;
  # %%
  '''
                                                                    80 columns ▽
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns △
'''
  # %#
}


{## Common Parts with Pervasive Languages
 # - Đ has good interoperability with Python/JavaScript etc. at source level

Đ shares some common syntax with many popular programming languages (e.g. Python, JavaScript), in a nutshell:

 * Parentheses pair is the call-making operator
 * Expressions consist of named references, joined together by prefix/infix/postfix operators with certain precedence and fixity/associativity
 * Parentheses for precedence override

 #} {;

  {## Common Syntax
   # - Đ syntax common to many popular languages
   #} {;
    {## Đ Common Syntax #}
    export edh'common'syntax = bookmark()

    # `console` hooks to the interpreter program's stdio
    # `console.print()` does exactly what you think it should
    # %%
    console.print( 'Đ code can have usual looking of Python, JavaScript etc.' )
    # %#

    # As a code cell is run by a REPL, the result of evaluation will be printed,
    # so you don't really need `console.print()` that often
    # %%
    1 + 2 - 3 * 7
    # %#

    # When precedence rule doesn't work outright, parenthese comes to rescue
    # %%
    1 + ( 2 - 3 ) * 7
    # %#
  }


  {## Chaining Comparison Operators
   # - Resemble how Python does it
   #} {;
    edh'chain'cmp'ops # <- follow this bookmark to the description in the grammar chapter

    # %% # Let's take these values for example
    let (x, y, z,) = (1, 2, 3,)

    # %% # It's quite like how Python supports it
    ; ( x < y <= z ) is true
    # %# Note `y` is only evaluated once there, as Python would do

    # %% # You can also chain equality comparisons together
    ; ( x != y == z ) is false
    # %%
    ; ( x != y == 2 ) is true

    # %% # But it's not always the same as in Python, Đ does not chain equality comparisons and ordering comparisons together, when mixed, the groups follow their `infixr 4` semantics, so this works:
    true == x < y <= z

    # %% # But this will err out:
    x < y <= z == true

    # %#
  }


  {## Module System
   # - Blend of several popular things
   #} {;
    {## Module System #}
    export edh'modu'system = bookmark()

    {## Runtime Module Representation
     # - Almost the same as Python and JavaScript

Đ has an explicit "World" concept & data structure, holding a world root scope, within which all shared "global" modules are defined, each module scope is an "inner" scope of the world root. In contrast, the Python and JavaScript runtime will populate each module with global artifacts, without any outer scope beyond those global modules.

Except that, the runtime representation of Đ, Python and JavaScript are the same, i.e. each runtime module can hold various artifacts and change dynamically, shared modules can import eachothers via certain import path specifications.

     #} {;
      {## Runtime Module Representation #}
      export edh'rt'modu'repr = bookmark()

      # %% # Obtain scope of current repl module
      s = scope()

      # %% # The direct outer scope of a module should usually be the world root
      worldRoot = s.outer

      # %% # You can see what's living there, they are available to code in a module lexically
      dir$ worldRoot

      # %% # The world root scope is lexically outer most, no further outer scope from there
      worldRoot.outer is nil

      # %#
    }

    {## Node.js Package Directory Hierarchy
     # - Directory layout for package deployment

  https://nodejs.org/api/modules.html

But you use `epm` to initialize EPM homes, install / update / remove pakcages in each home manually, instead of the full-automatic `npm` tool.

  https://github.com/e-wrks/epm

     #} {;
      {## Node.js Package Directory Hierarchy #}
      export edh'pkg'layout = bookmark()
    }


    {## ES6 import/export Syntax
     # - Dedicated `import` and `export` keyword

  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules

You use explicit `export` keyword to decorate artifact definitions (e.g. assignments, procedure/class declarations), for them to be importable by other modules (or objects).

The `import` keyword is used to denote an import expression, the expression evaluates to the object resolved as the source for import, and with a side effect of artifacts exported from that object to be received into current scope, however specified by the arguments receiver part of the import expression.

     #} {;
      {## ES6 import/export Syntax #}
      export edh'imp'exp'syntax = bookmark()

      # Note that the import/export mechanism works with any object in Đ, module objects as well
      edh'imp'exp # <- follow this bookmark to the section describing the detailed syntax and semantics in the grammar chapter

    }


    {## Python Module File Naming Convention
     # - Special module files like `__init__.edh` and `__main__.edh`

  https://docs.python.org/3/tutorial/modules.html

Đ module files ends with `.edh` extension name, special cases include:

 * `__init__.edh` can stand for the import target as its parent directory, relative imports within it work more intuitively than a file module with its parent folder's name plus the `.edh` suffix.

 * `__main__.edh` stands for the entry module source file, when its parent directory is resolved as the entry module of an interpreter process.

Note that `__main__.edh` is the only valid entry module file name, unlike Python. An otherwise named module file will never be run as an entry module.

     #} {;
      {## Python Module File Naming Convention #}
      export bookmark'identifier = bookmark()
    }


    {## Python Module Semantics
     # - Strict loading and meta artifacts

The module loading semantics is similar to Python, every statements at top levels will be strictly executed in a sequence. The cyclic importing (with possibly multiple levels of indirections) cases are also handled similar to how Python does it.

     #} {;
      {## Python Module Semantics #}
      export edh'modu'loading'meta'arts = bookmark()

      edh'modu'load'cyc # <- follow this bookmark for detailed describption of loading semantics, including cyclic loading cases


      {## Reflective Attributes in a Module
       # - Every module object contains some meta attribute to reflect its source information
       #} {;

        # %% # It should at lease contain the `__name__` attribute, similar to Python
        __name__

        # %% # File modules should contain `__file__` for absolute file path of the source file as well, similar to Python
        __file__

        # %#
      }

    }

  }


  {## Minor but Subtle/Surprising Differences
   # - You might be surprised by a few things though
   #} {;

    {## String Literals
     # - Almost all possible forms are valid here

In an era without code syntax highlighting, multi-line strings can be adversely confusing, but nowadays no text editor can claim itself being a code editor without proper syntax highlighting. So Đ allows a string literal to span multi lines anyway, dunno if this can trip someone up, but be aware.

     #} {;
      {## String Literals #}
      export edh'str'literals = bookmark()

      # %%
      'single-quote, single-line string'
      # %%
      'single-quote,
multi-line string'
      # %%
      "double-quote, single-line string"
      # %%
      "double-quote,
multi-line string"
      # %%
      `tick-quote, single-line string`
      # %%
      `tick-quote,
multi-line string`
      # %%
      '''triple-single-quote, single-line string'''
      # %%
      '''triple-single-quote,
multi-line string'''
      # %%
      """triple-double-quote, single-line string"""
      # %%
      """triple-double-quote,
multi-line string"""
      # %%
      ```triple-tick-quote, single-line string```
      # %%
      ```triple-tick-quote,
multi-line string```

      {## Trailing Spaces in Multi-line String Literal
       # - It'll be removed by Đ code formatter

One particar note for multi-line strings, though:
  ALL TRAILING SPACES will be REMOVED by Đ code formatter
That includes such spaces inside a multi-line string literal, you need a workaround just in case.

       #} {;
        {## Trailing Spaces in Multi-line String Literal #}
        export edh'fmt'rm'trail'spc'in'str'lit = bookmark()

        # %%
        """You'll need tricks like   """ +
        """this to preserve space(s), which otherwise,
will be at the end of a source line."""
        # %#
      }
    }

    {## Rational Decimal Numbers
     # - Don't take floating point numbers for granted

Floating point arithmetic is intrinsic to numbers represented natively in most computer programming languages of today, see:

> What Every Programmer Should Know About Floating-Point Arithmetic
  https://floating-point-gui.de/

Python `float` and JavaScript `number` are all subject to those gotchas.

     #} {;
      # %% Check it in Đ then:
      0.1 + 0.2
      # Oops! Not the case you'd encounter with Python or JavaScript

      # %% Then see result of this:
      x = 7 / 3
      # %% And this:
      x * 9
      # You get it? Numbers can be lossless-fractional in Đ

      # %% And in case you need integral division, use (//) as in Python
      7 // 3
      # %#

      edh'rat'decimal # <- follow this bookmark to the detailed section in the grammar chapter

      # Takeaway is:
      #   Numbers in Đ are lossless (to the extent of rational numbers)
      # Well please keep in mind that comes at a rather high cost, both spacial and time complexity are much higher to work with numbers in Đ, than in other languages.

      # The overhead is justified for ergonomics concerns where human errors can be disastrous, and raw machine performance should be pursued by perfessionals and by meaning means, such as the approach of `hasdim` you'll see at:
      import * 'dim/tour' into Nothing
    }


    {## Single Quote in Identifiers
     # - It came from Haskell, and Math in turn

The single quote character (') can appear in an identifier, only if it's not the first character.

     #} {;

      # %% # In Haskell and Math, a suffix ' is used to denote something slightly different from the symbol without it:
      let ( x, y ) = ( 7, 3 )
      let ( q, q' ) = ( x / y, x // y )
      'Is ' ++ q' ++ ' equal to ' ++ q ++ " ? That's " ++ ( q'==q ) ++ ' of course!'
      # %#

      # There are norms in Haskell for two or even more ' as the suffix, and technically it can appear anywhere except being the start of an identifier, it's the same in Đ

      {## An Unnamed Naming Convention
       # - Or do you know its name?

About naming conventions, quoting:
  http://www.wellho.net/mouth/4611_Hungarian-Camel-Snake-and-Kebab-variable-naming-conventions.html

Camel case: numberOfPeople
A series of words, with each intermeidiate word started with a capital letter. Called "Camel Case" because the capital letters make it look like the humps of a camel.

Kebab case: number-of-people
Hypehated words - like chunks of meat or vegatables on a kebab skewer. Note that cannot case only works in a gew languahes such as Tcl and Perl 6, as the minus sign most usually is the subtraction operator.

Snake case: number_of_people
Words separated with underscores - the word snakes along past the underscores. Unlike Kebab case which is of limited (language) use, you can use Snake Case with most modern languages.

Hungarian (Systems) notation: iNumberOfPeople
In hungarian notation, you preceed the variable name with an additional character or characters to indicate the type of variable - in Hungarian Systems notation, that's an indiction of the internal data type such as i for Integer. You can see the developemnt of Hungarin Systems Notation from old Fortran conventions where variable names starting with I J K L M or N were integers, and others were floats.

Hungarian (Apps) notation: cntNumberOfPeople
Prefixing the name of the variable with character(s) to indicate the use make of a variable within the application - in my example, I have used cnt to incicate it's a counter ... and in my old Fortran programs you'll find "JPxxxxx" all over th eplace to indicate an integer pointer.

       #} {;

        # %% # In Đ more usages of ' can be seen, such as word delimiters in a long identifier, maybe a whole new naming convention, but dunno its name:
        number'of'people :: non'negative!int!Decimal
        number'of'people = 5
        # %# Note about (::) and (!), they are annotation operators in Đ, will be explained later

      }
    }
  }

}


{## Terminology Differences
 # - Some similar things are named differently
 #} {;

  {## Procedure instead of Function
   # - There are procedures, but no functions

A *function* in mathematics has well defined input and output, it can refer to nothing outside of its immutable input (though with enclosed implicit parameters included). Functional programming langauges e.g. Haskell, reflects such constraint well. But unfortunately many procedural / imperative programming langauges, tracing back to C and other ancestors, defined their "function"s with ability to access mutable global / closure "variable"s (The "variable" there is albeit another misconception agsinst mathematical variables), so side-effects can be there out of trivial reasonability by programmers in the day, leading to more bugs in software developed comercially.

It's not a big deal for Đ the language to have stopped refering to impure computations (with side-effects and mutable input) as "function"s, but more conforming conception is a good start to put effect tracking as a focus for the programming tools, looking forward for greater quality in the software developed as the result.

   #} {;
    {## Procedure instead of Function #}
    export edh'term'proc'stead'func = bookmark()
  }


  {## Attribute instead of Variable
   # - There are attributes, but no variables

There is no such a concept/term of "variable" in Đ. The "variable" concept in conventional programming languages is misleading or conflicting when you could possibly have mathematical concepts in the domain model of your business. More properly it should be called "assignable" as suggested in:
  https://existentialtype.wordpress.com/2013/07/22/there-is-such-a-thing-as-a-declarative-language

Although attributes of entities in Đ are inherently meant to be assigned (as well as to be observed), they can not stand alone without a backing entity. Unlike in conventional programming languages, where a "variable" can be assigned individually.

   #} {;
    {## Attribute instead of Variable #}
    export edh'term'attr'stead'var = bookmark()
  }

}


{## Code Structure & Semantics
 # - Similar to Python, JavaScript, etc. but with subtle differences

Đ source code is organized as modules, some defined by code in the host programming language, some loaded from respective source files from the filesystem. Modules export artifacts for reuse, while importing artifacts from others, quite similar to Python codebases or JavaScript codebases consisting of ES6 modules.

Closure in Đ is more coarse grained - entire scopes, instead of individual "variable"s are enclosed. It makes Đ programs more potent to resource leaks though, so more care should be taken by the programmer, to clear references to resource values as soon as not needed anymore.

 #} {;
  {## Code Structure & Semantics #}
  export edh'code'struct = bookmark()


  {## Name / Identifier
   # - The so called *variable identifier* or *variable name* elsewhere

All data in an Đ world is stored as attributes associated with certain entities under some name. Both (non-host) objects and scopes are backed by entities, the naming mechnism works at the entity level, so stays the same for both objects and scopes.

   #} {;
    {## Name / Identifier #}
    export edh'name'identifer = bookmark()

    {## Usual, Alphanumeric Names
     # - Just like how *variable*s can be named in other programming languages such as Python
     #} {;

      # Most programming languages allow only alphanumeric strings as "variable" identifiers, with limited choices of special characters (such as the usual underscore (`_`), and `$` in Java)

      # Đ allows underscore (_) and the single-quote character (') in alphanumeric names, this is following Haskell, and more scientific naming friendly.

      edh'alphanum'names # <- follow this bookmark to the detailed secion in the grammar chapter

    }


    {## Symbolic Names
     # - Cross component encapsulation of implementation details

JavaScript introduced symbol, which is allowed as identifier of object properties:
  https://developer.mozilla.org/en-US/docs/Glossary/Symbol

Đ takes this idea further, gives it bigger purpose, and dedicated syntax.

Like other dynamic programming languages such as Python, JavaScript, Đ objects (and scopes) are openly accessible, but with symbol key values eligible as symbolic attribute names, Đ programming interfaces can have multiple level of encapsulation, that even more flexible than what's supported by Java, C++ and similar languages.

Java has private/protected/public and the implicit package qualification to limit access to fields of a class, C++ has private/protected/public qualification plus friend declarations. In Đ, you define symbols to be used as the name of such fields (attributes of objects / scopes), then you can export the symbol key values differently than how the class (or namespace etc.) is exported. Other components can import these keys and use them to access such symbolic fields, as if they are public, or those fields will appear private/hidden to them. Different contracts with different sets of available symbols can be defined and exposed to different parties, for different levels of knowledge & access to the same codebase of implementation details.

     #} {;

      edh'symbolic'names # <- follow this bookmark to the detailed description of symbolic names and at-notations in the grammar chapter


      # %% # The `symbol` keyword is used to define new symbol keys
      symbol @secret'stuff

      # %% # Directly assign to symbolic attribute into current scope
      ; @secret'stuff = 'a bit of mysterious'

      # %% # Directly obtain a symbolic attribute from current scope
      ; @secret'stuff

      # %% # The at-notation works as argument name, as well as attribute name in dot-notation
      namespace shared'ns ( @secret'stuff= 'This is public to whoever knows the key', ) {

        # Assign symbolic object attribute with dot-notation
        this.@secret'stuff ++= ", but private to ones don't."

      }

      # %% # Obtain symbolic object attribute value via dot-notation
      shared'ns.@secret'stuff

      # %#
    }


    {## Quaint Names
     # - Technically, any text can be used as attribute name

Special characters don't get in the way for you to use strings containing them as attribute identifiers. This comes handy in some cases, e.g. LSP (Language Server Protocol) service names tend to have slash `/` characters in it, but the Đ language server defines such service methods with verbatimly such names in the code, while you have to use dynamic data structures for such implementations in other languages.

     #} {;

      edh'quaint'names # <- follow this bookmark to the detailed section in the grammar chapter

      # %% # Assign an attribute with a dash in its name
      shared'ns.@'full-time' = true

      # %% # Obtain such an attribute
      shared'ns.@'full-time'

      # %% # Check all attributes there
      dir$ shared'ns

      # %#
    }

  }


  {## Scopes - Lexical & Dynamic
   # - Lexical (static) scoping & effect (dynamic) scoping

Lexical scoping rules of Đ are comparable to that of Python, JavaScript etc. but with gotchas (described in the section below).

Đ also does dynamic scoping to foster effect tracking, which is never supported in similar languages.

   #} {;
    {## Scopes - Lexical & Dynamic #}
    export edh'scope'callstack = bookmark()

    edh'scope'hierarchies # <- follow this bookmark to the detailed description in the grammar chapter


    {## Scope Backed by Entity & Attributes
     # - A scope is backed by an entity

A scope in Đ is more dynamic and long living than that in Python or JavaScript, there is no such thing as "variable declaration" or "variable binding" in Đ, since there is no "variable" in the first place. There are only "attributes in scope", an individual attribute can never stand alone, neither can it "escape" to some closures with its owning scope disposed. Attributes of a scope can be added/changed/deleted dyanmically at runtime at anytime, all these operations are accomplished by assignment, and an assignment in Đ always have an owned attribute as the target, especially the case of procedure scope attribute assignments, quite unlike assignments to "function local variables" as in other programming languages.

Every scope is backed by a particular entity, be it a procedure scope, or an object scope - including module scopes and namespace scopes. Those "attributes in scope" are technically attributes belong to the scope's backing entity. Further more, there are lexical scoping rules including shadowing.

     #} {;
      {## Scope Backed by Entity & Attributes #}
      export edh'scope'backing = bookmark()

      # For what's an entity
      edh'entities # <- follow this bookmark to the detailed description in the grammar chapter


      {## Attribute Deletion
       # - By assigning `nil` to it

Instead of Python's `del` statement or JavaScript's `delete` operator, assignment with `nil` does that job in Đ

       #} {;
        {## Attribute Deletion #}
        export edh'attr'deletion = bookmark()

        # %% # A usual assignment
        x = 3

        # %% # Check it does be in scope
        x

        # %% # Deleting it
        x = nil

        # %% # Try obtains it now
        x

        # %# See? Not in scope anymore, after deletion.

        {## Implication
         # - Prefer `case-of` to receive result from nil-prone expressions & procedures

So you should use direct assignment to an attriute, only in cases of:

  * You are sure the rhs result can not be `nil`
  * Deletion of that attribute is expected, per conditions the rhs evaluates to `nil`

In other cases, you want to use `case-of` to explicitly handle `nil` case, either with a `nil` value match, or with the default branch after other capturing branches.

         #} {;
          {## Implication #}
          export edh'attr'del'implication = bookmark()
        }
      }

    }


    {## Lexical Attribute Resolution & Shadowing
     # - Similar to "variable" resolution in Python, JavaScript etc.

Direct attribute obtaining is very close to "variable" reading in similar languages, that inner scope attribute with the same name will shadow those live in outer scopes. But it is more dynamic in Đ - the attribute can be deleted from the inner scope, then your reads will immediately resolve to an outer attribute previously shadowed - this is not the case with either Python or JavaScript.

Then you have no way to assign attributes into an outer scope (workaround exists though), scoped assignments (not with dot-notation as target) will always go into current scope. There is neither `nonlocal` hints as in Python, nor explicit "variable" declaration (the `var` keyword) as in JavaScript. Prevalent dynamic namespace objects should be the norm in Đ code for this reason, to convey artifacts meant to be assigned by code running in inner scopes, via dot-notations (which is the workaround).

     #} {;
      {## Lexical Attribute Resolution & Shadowing #}
      export edh'lexi'resolv = bookmark()

      # %% # We demonatrate it with a scoped block here
      x = 'outer-value'
      {@
        console.print$ 'Inside, before local attr definition, x is: ' ++ x
        # Upon entering a scoped block, a new lexical inner scope (backed by a separate entity) is created right away, then attributes can be defined locally. And an attribute present in an inner scope shadows all ones with the same name from outer scopes.
        x = 'inner-value'
        console.print$ 'Inside, after local attr definition, x is: ' ++ x
        # Dynamic deletion of an attribute works and matters here
        x = nil
        console.print$ 'Inside, after local attr deleted, x is: ' ++ x
        # All attributes left in a scope will be discarded, after control leaves the scope (unless some procedures defined in the scope are sent out and kept live elsewhere, as those procedures _enclose_ their lexical contextual scopes)
        x = 'inner-again'
      @}
      console.print$ 'Outside, x is: ' ++ x
      # %# No access to artifacts in an inner scope from outer

      # Note it is an anti-pattern to shadow attributes living in outer scopes, the code above is for demonstration purpose only and not idiomatic. Scoped blocks should be just used to discard its scope attributes upon leaving, it's discouraged to override attributes available from outer scopes like that.


      # %% # Ad-hoc defined namespaces can serve as the container of attributes assignable by any code having read access to the namespace object

      namespace state (n= 10) pass

      method count'down() state.n -= 1

      # %% # See it works (repeat running this cell more times for better intuition)
      count'down()
      state.n

      # %#
    }


    {## Effect Tracking by Dynamic Scoping
     # - A unique feature of Đ

Dynamic scoping - attribute resolution against the calling stack of caller frames - is seldom seen in modern programming languages anymore, but Đ is doing it for effect tracking, with solution to its historical problems.

     #} {;
      edh'dyn'scoping # <- follow this bookmark to the detailed description in the grammar chapter

    }

  }


  {## Namespaces
   # - Similar to TypeScript namespace

An Đ namespace is a special object defined with dedicated syntax. It's fairly norm to create namespaces ad-hoc during a procedure call, which carries more dynamic semantics, in addition to more "statically" defined namespaces at top level of module initialization.

   #} {;
    {## Namespaces #}
    export edh'namespaces = bookmark()

    edh'namespaces # <- follow this bookmark for the detailed syntax and description in the grammar chapter

    # Alternative to Python `nonlocal` "variables", namespaces live in outer scope can hold attributes meant to be assigned by some code run in inner scopes.

    # Alternative to JavaScript hoisting, a procedure can be defined earlier to contain code wanting to call other procedures defined later.

  }


  {## Scoped Blocks
   # - A usual block doesn't create a nested scope, use special syntax to do that

Unlike in C and its offsprings, but rather like in Python, JavaScript, Go etc. a usual block (indentation denoted in Python, curly brace denoted in JS and Go) in Đ does not create a nested scope.

You have to use an ad-hoc'ly called "function" in Python, JS or Go, to create nested scopes, sth what you do with just curly braces in C family languages (including Java, C++ etc.). Đ offers special syntax to do it easily.

   #} {;
    edh'scoped'blocks # <- follow this bookmark to the detailed description in the grammar chapter

    # %% # A scoped block is denoted by a pair of curly braces augmented with at (@) symbol. As with a usual block, it evaluates to result of the last statement (usually an expression statement) in it

    y = nil # Let's clear `y` out of the REPL top scope for sure

    { # This starts a usual block

      x = 3 # This goes into the REPL top scope, as evaluated in a usual block

      {@ # This starts a scoped block

        y = 7 # This goes into the scope created by the scoped block

        x * y # This provides the result value for the whole scoped block, as last expression in it

      @} # This ends the scoped block. Note `y` is not in scope since here on

    } # This ends the usual block, with the result from that of the inner scoped block, as the scoped block is the last statement of this usual block

    # %% # The nested scope created by a scoped block goes out after execution left that block
    x + y
    # %# See the error? `y` is not in scope here

  }


  {## Coarse Grained Closure
   # - A procedure always captures the full lexical context where it is defined

As a consequence of the way attributes are resolved lexically, a procedure remembers the full hierarchy of its lexical outer scopes as in where it is defined. We say a procedure captures its enclosing context as a closure.

Note that Đ closure is rather coarse grained compared to many other programming languages, closures elsewhere usually capture individual "variables" they actually access as statically witnessed; while in Đ it is actually the entities behind the lexical scopes get captured, so dynamic access is possible to whatever in there at runtime.

   #} {;
    {## Coarse Grained Closure #}
    export edh'closure = bookmark()

    # Such closure semantics is designed to allow dynamic evaluation/execution of Đ snippets anywhere anytime, honoring entities being integral units of information, without individual attributes teared apart.

    # But it may lead to unintentional resource leaks, especially if you've been used to closures in other mainstream programming languages.

    # TODO demonstrate gotchas of resource leaking due to the coarse grained closure.

  }


  {## Builtin Data Structures
   # - There are similar intrinsic data types as in Python, JavaScript and ets.
   #} {;
    {## Builtin Data Structures #}
    export edh'builtin'data'structs = bookmark()

    {## ArgsPack - the Super Tuple
     # - The super type of tuple with named elements

The apk type is a super type of the "tuple" type, Python, Haskell and many other languages have a tuple type.

An apk with only positional arguments carries exactly the same semantics of a "tuple".

An apk with only named arguments is comparable to the "namedtuple" in Python, but it is structurally typed in Đ, while "namedtuple" is nomially typed in Python per se.

Then in Đ positional arguments and named arguments can be combined together in a single apk.

     #} {;
      {## ArgsPack - the Super Tuple #}
      export edh'apk'super'tuple = bookmark()

      # %% # Positional only apk
      ; ( 3, 2, 5, )

      # %% # Named/Keyword only apk
      ; ( a=3, c= 'Hello', b= 'World!', )

      # %% # Apk with both positional and named arguments
      ; ( 3, 2, 5, x= 9, s= "There's more.", )

      # %# Apk is immutable and there are implications wrt equality, (un/re)packing, argument deletion etc.
      edh'apk # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }


    {## Vector
     # - Like Array in Javascript, list in Python, with preliminary vectorization

Vector is a mutable type, optimized for index based random access, and supports preliminary vectorization with several operations get broadcasted element-wise.

     #} {;
      {## Vector #}
      export edh'vector'vs'js'py = bookmark()

      # %% # Vector constructor takes all positional arguments, so arg unpacking together with apk comphrehension can be used to initialize a Vector
      v = Vector( *()=< do i for i from 0:10 )

      # %% # A Vector can be sliced with a <start>:<stop> pair
      # Note that <start> is inclusive and <stop> is exclusive, which is the same syntax and semantics as in Python
      v[3:8]

      # %% # Reversed slicing works too, but notice the inclusive/exclusive semantics
      v[7:2]

      # %% # Custom step can be specified
      # Note this is still the same syntax and semantics as in Python
      v[3:8:2]

      # %% # But you'd make sure the stepping is monotonic, this will fail e.g.
      v[7:2:2]

      # %% # This is the correct spec
      # Note a subtle difference from Python here, minus (:) has to be separated from colon (:), or edh
      v[7:2: -2]

      # Note the slice specificatons are pairs in Đ, unlike slice objects used in Python, so the syntax is not exactly the same as in Python. While in Python you can omit the value at either end of a slice index, e.g. `v[3:]` and `v[:8]`, you can't write that way in Đ.
      # %% # You'd use the special `All` and `Any` value to indicate unknown index bounds
      v[3:All]

      # %% # `Any` has stronger element-wise sematics than `All`, but in many cases they are interchangable
      v[Any:8]

      # %# Though greatly resembling Python indexing, the syntax and semantics are not verbatimly the same
      edh'index'vals # <- follow this bookmark to the detailed description in the grammar chapter

      # %% # Constructing a simple vector
      v = Vector( 3, 2, 5, )

      # %% # Broadcasted (+) operation
      v + 100

      # %% # The same when at rhs
      100 + v

      # %% # Broadcasted (++) operation
      v ++ 5

      # %% # The same when at rhs
      5 ++ v

      # %% # Broadcasted comparison
      v >= 3

      # %% # Masking with comparison result
      v[ v >= 3 ]

      # %% # Conditional update masked with comparison result
      v[ v >= 3 ] += 100
      v

      # %% # Another conditonal update example with string operation
      v[ v > 10 ] ++= ", which is too large"
      v

      # %% # TODO impl. and demo. `.map()` `.update()` etc.

      # %# Vector demonstrates how host objects and magic methods work
      edh'vector # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }


    {## List
     # - Like list in Haskell, but mutable

Đ list is a builtin singly linked list data structure, it is optimized for prepend and sequential scan, quite like Haskell list. But while Haskell list is immutable, Đ list is mutable, meaning modification to an Đ list will be visible to any code holding a reference to the list.

     #} {;
      {## List #}
      export edh'list'vs'hs = bookmark()

      # %% # The list literal syntax is quite like that in Python as well as Haskell
      l = [ 3, 2, 5, ]

      # %% # Đ prepand (:>) operator works like Haskell's single-colon syntax to prepand an element to a list. But unlike in Haskell, the underlying list value is actually modified, though the result feels like that in Haskell for the operation evalutes to the updated list, with the lhs element prepended.
      9 :> l

      # %% # Đ list is ploymorphic / heterogeous due to dyanamic nature of the langauge, i.e. values of different types can be stored in the same list
      'Some text' :> l


      # %% # `push()` and `pop()` can be use with a list for "stack" semantics
      h = l.pop()
      'After ' ++ h ++ ' popped, l now is: ' ++ l

      # %% #
      l.push(7)
      l

      # %#
      edh'list # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }


    {## Dict
     # - Like Object in JavaScript, dict in Python

Đ dict is a hash map data structure, optimized for O(1) key lookup as well as sequential scan, just like Python dict and JavaScript Object. It is more like Python dict in Python 3.7 and later versions, that the entry order when iterated will preserve the order as they get inserted. Earlier versions of Python and JavaScript, as well as most mainstream programming languages, don't make such guarantee.

     #} {;
      {## Dict #}
      export edh'dict'vs'js'py = bookmark()

      # %% # Đ dict literal syntax resembles that in Python
      d = { 'c': 3, 'a': 2, 'b': 5, }

      # %% # So does the `dict` constructor, it resembles Python too
      d' = dict( c= 3, a= 2, b= 5, )

      # %% # Dicts can be compared for instant equality test
      d == d'

      # %% # But two dicts are never identical
      d' is not d

      # %% # Though different references can point to the same dict value, which is a mutable container per se
      d'' = d
      d'' is d

      # %% # `push()` and `pop()` can also be use with a dict
      d = dict( c= 3, a= 2, b= 5, )
      v = d.pop( 'a')
      'After a=' ++ v ++ ' popped, d now is: ' ++ d

      # %% #
      d.push( 'a', 9 )
      d

      # %# Any Đ value can be used as dict key (including symbols), and there are implications as identity equality is used for dict keys in Đ
      edh'dict # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }


    {## Pair
     # - More general slice as in Python

Technically speaking, Đ pair is immutable singly linked append cons list, but it is mostly used in place of slices as in Python, as well as dict entry specifiers, instead of a general list.

Unlike slice in Python, the colon (:) operator can construct new pairs in anywhere, not just as index enclosed by square brackets ([]). Also technically it is not restricted in slice usage, but more general.

     #} {;
      {## Pair #}
      export edh'pair'vs'py'slice = bookmark()

      # %% #
      let (a,b,c,) = (3,9,2)
      ; ( 3:9:2 ) is ( a:b:c )

      # %% # The (:) operator is left-associative, please intuit this difference so you don't get confused in similar situations
      ; ( 3:(9:2) ) != ( (3:9):2 )

      # %% # Though they have identical repr
      repr( 3:(9:2) ) == repr( (3:9):2 )
      # TODO maybe the repr should be fixed to avoid confusions

      # %#
      edh'pair # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }


    {## Message Channel
     # - Like the unbuffered `chan` in Go

Đ message channel is like unbuffered channel as in Go, with synchronous message passing semantics, though works asynchronously.

An Đ channel can have multiple producers and multiple consumers at the same time, but each particular message is only received by one consumer at most, i.e. the (possibly load-balanced) unicast semantics.

The (<-) operator in Đ resembles that in Go, it does channel write when used as infix op, and does channel read when used as prefix op. The message stream through a message channel can be further iterated with (possibly concurrent) for-loops, as well as each message value to be individually perceived in a preemptive fashion, by many Đ threads.

     #} {;
      {## Message Channel #}
      export edh'msg'chan'data'struct = bookmark()

      # %% # Use the `chan` keyword to construct a new channel value
      ch = chan

      # %% # Use the infix (<-) operator to write to a channel
      # Note it has to happen on a separate thread other than the REPL, synchronous/blocking write to a channel, which has no (process wide) reader (threads) will be, detected by GHC RTS (STM) as a deadlock situation, thus to have your Đ session crash.
      go { # Note channel writes are synchronous / blocking
        ch <- 'Hello there!'
        console.info<| 'Hello said.'
        ch <- 'You look great!'
        console.info<| 'Flattery said.'

        ch <-nil # Mark it end-of-stream, by writting a nil into the channel
        # Note this does NOT blocking, contrary to normal message writes.
        console.info<| 'Channel closed.'
      }

      # %% # Use the `.eos` virtual attribute to check if a channel has reached end-of-stream
      ch.eos

      # %% # Use the prefix (<-) operator to read from a channel
      # Execute this cell for more times to see all those messages and effects
      msg = <-ch

      # %% # See once the channel reaches EoS, you always read a `nil` out of it immediately
      ; <-ch is nil # semicolon used to disambiguate (<-) as a prefix op instead of infix one

      # %# Note: in case a channel is not at EoS, and there remain only (blocking) readers, GHC RTS (STM) will detect a deadlock situation, thus crash your Đ session. This can happen if the above cell didn't issue `ch <-nil` at last.


      # A message channel defines an unbuffered, load-balanced, message stream
      edh'msg'chan'values # <- follow this bookmark for the detailed syntax and description in the grammar chapter

      # For message stream iteration
      edh'iter'msgs # <- follow this bookmark for the detailed syntax and description in the grammar chapter

      # For preemptive message handling
      edh'perceive'msgs # <- follow this bookmark for the detailed syntax and description in the grammar chapter
    }

  }


  {## Control Flows
   # - Commonplace ones and more

Semantically, Đ is heavily influnced by the functional Haskell langauge, i.e. most control flow constructs are expressions, contrasting to Python, JavaScript, Go and other C influnced languages, where control flow constructs are mostly statements not evaluating to results but just side-effects.

Some syntaxes also follow Haskell, e.g. the if-then-else expression, as well as the semantics.

Though Đ at the same time tries to be syntatically compatible with JavaScript as much as possible, so some JavaScript styled syntaxes are also accepted, and some of them even carry the same or similar semantics. E.g. `then` can be omitted in an `if` expression, `from` keyword can appear in `import` expressions, `const` is allowed in places of `let` (but with same semantics), etc.
   #} {;
    {## Control Flows #}
    export edh'ctrl'flows = bookmark()

    {## If Expression and Tenary Operator
     # - About binary choices

In C as well as Python, JavaScript etc., the if-else construct is a statement, when a result is expected from either of two expressions, based on a certain condition, there usually exists a form of tenary operator (though with different syntax) in different languages to do the job.

In Haskell, all control flow constructs are expressions, Haskell's `if <cond> then <truthful> else <falsy>` construct is more like C's tenary operator `<cond> ? <truthful> : <falsy>` rather than C's if-else construct (which is a statement).

In Python, `and` plus `or` operator can work together to simulate C's tenary operator, just more flexible, as it can take advantange of its dynamically typed nature.

     #} {;
      {## If Expression and Tenary Operator #}
      export edh'binary'choices = bookmark()

      # %% # Đ follows Haskell in the if-then-else construct, both semantically and syntatically
      verbosity = if console.logLevel <= console.debug then 2 else 1

      # One thing unlike Haskell, the `else` part can be omitted in Đ, this is possible because Đ is dynamically typed, the whole expression can evaluate to `nil` in case the condition is not met and no `else` clause presents. While in Haskell no meaningful default can be implied so you have to always write an `else` clause. It's not idiomatic Đ though, to omit the `else` part when the `if` expression is used as right-hand-side operand of an assignment, as `nil` carries attribute deletion semantics in assignment, it is burdensome to reason about the intention, with both update and deletion of the attribute possible with a single assignment.

      # %% # The `else` part can be idiomatically omitted, when the result of the `if` expression is not used at all
      if verbosity > 1 then console.print( "I'm chatty.")


      # Đ has `and` and `or` operator working almost verbatimly the same as those in Python
      # %% # The above cell can be written like this as well, both are idiomatic
      verbosity > 1 and console.print( "I'm chatty.")


      # %% # The tenary operator of C can be simulated with `and` plus `or` combined, this is the only (obvious) idiomatic way in Python, but you could prefer if-then-else in Đ as an equivalent idiomatic way. Compare this with the equivalent cell above
      verbosity = console.logLevel <= console.debug and 2 or 1

      # %% # Actually, if you are fond of Guards or MultiWayIf in Haskell, you'd probably like value matching against `true` in Đ like this
      verbosity = case true of {
        console.logLevel <= console.debug -> 2
        _ -> 1
      }
      # %# The (->) operator is literally branch in Đ, it facilitates pattern matching (as well as value matching you see), to be described later

      # %#
    }


    {## For Loop
     # - Remotely the traditional for loop

Đ has a for-from-do loop construct. On the surface, the semantics is quite the same of for-in loop as in Python, and for-of loop as in JavaScript.

But the syntax involves the `from` keyword and an extra `do` keyword, it becomes quite different from Python's `in` keyword and JavaScript's `of` keyword, which already being different from C's freeform for loop.

Deeper in the semantics, `from` is chosen to carry the implication that the source of iteration is remote to current looping context, and is processed in a streaming fashion. The source is possibly infinite (e.g. the event stream of Bitcoin/USD quotes) or very large (e.g. all historic bid records of a stock) to be loaded at its entirety, The `do` keyword then emphasis that the loop body is executed locally in contrast.

Such intuition is very true when looping against an message channel (either from a producer procedure or not), and also quite true when looping against some effectful generator procedure resolved dynamically, i.e. unknown to the looping site.

     #} {;

      # %% # An Đ `for` loop can do exactly the same things as in Python, JavaScript, and etc.
      for i from [3, 2, 5,] do console.print(i)

      # %% #
      for i from 1..3 do console.print(i)
      # %% #
      for i from 1..^4 do console.print(i)
      # %% #
      for i from 0^..3 do console.print(i)
      # %% #
      for i from 0^..^4 do console.print(i)
      # %% #
      for i from 1:4 do console.print(i)

      # %% #
      for i from 10..8 do console.print(i)
      # %% #
      for i from 10..^7 do console.print(i)
      # %% #
      for i from 10:7 do console.print(i)

      # %% # Moreover, it can loop against unpredictable streams
      msgCh = chan
      # Spawn a separate thread to do the loop so REPL still usable along with the loop
      go for msg from msgCh do console.info<| 'Got msg: ' ++ msg
      # Note the message through `console.print()` will be blocked during REPL's prompting for input, so here the log (<|) operation is preferably used instead

      # %% # Messages can be posted from anywhere
      msgCh <- "You're great!"
      # Note the channel read/write (<-) operator (which is quite the same as in Go)

      # %% # And any sort of messages is possible, such as a fractional number
      msgCh <- 7/11


      # %% # Generators yield the values to be looped
      generator g() {
        yield 3
        yield 2
        yield 5
      }

      for i from g() do console.print(i)


      # %% # The `do` loop body can appear first
      do console.print(i) for i from 3..5

      # %% # Which reads nicer in comprehensions
      [] =< do i*3 for i from 3..5

      # %#


      {## Đ Resource Manager #}
      edh'res'manager = bookmark()

      # %% # Interestingly, a generator procedure can be used to implement something coined as resource managers in Python, when Đ for-loop to be used as the `with: ` syntax as in Python

      generator withResource( resArgs ) {
        console.info<| 'allocating [' ++ resArgs ++ ']'
        res = 'allocated [' ++ resArgs ++ ']'
        {
          # unlike in Python, a generator procedure in Đ can only be call by a for-from-do loop, and exceptions occurred in that do block will be propagated to the yield expression here
          yield res
        } @=> { # unlike generator in Python, this `finally` block is guaranteed to run in Đ
          console.info<| 'releasing [' ++ resArgs ++ ']'
        }
      }

      # the for-from-do loop can act like Python's `with`
      for res from withResource( 'some-resource' ) do {
        console.info<| 'using ' ++ res
        throw IOError( 'some failure' )
        break # or no exception but loop broken
        return nil # or early return from the loop
      }

      # %#

      # The detailed syntax and more examples are described in the grammar chapter
      edh'for'loop # <- follow this bookmark to the secion there
    }


    {## while & do-while Loop
     # - Same as JavaScript and other C family languages, and Python partially
     #} {;
      edh'while'loop # <- follow this bookmark to detailed syntax and description in the grammar chapter

      # %% #
      i = 3
      while i < 9 {
        console.print( 'Square of ' ++ i ++ ' is ' ++ i*i )
        i += 1
      }

      # %% #
      i = 3
      do {
        console.print( 'Square of ' ++ i ++ ' is ' ++ i*i )
        i += 1
      } while i < 9

      # %#
    }


    {## go Routines
     # - Like goroutines in Go

Đ implements go routines with 1:1 mapping to Haskell/GHC RTS lightweight threads, in addition to usual coroutine features, Đ threads can preemptively perceive message channels, as well as `defer` clenup actions, i.e. schedule those actions to run on thread termination.

     #} {;
      edh'go'routines # <- follow this bookmark to detailed syntax and description in the grammar chapter
    }


    {## Exception Handling
     # - Like that in JavaScript and Python

Despite the surface syntax - ($=>) operator instead of the `catch` keyword, and (@=>) operator instead of the `finally` keyword - single threaded exception handling in Đ has the same semantics and pragmatics like that in JavaScript and Python.

While an exception handler on a forker thread can handle exceptions occurred in forkee threads spawned during its try action, if uncaught by the forkee thread itself.

     #} {;
      edh'exception'handling # <- follow this bookmark to detailed syntax and description in the grammar chapter

      # Handling exceptions for forkee threads can help implement structured concurrency, there is an advanced topic describing why & how to implement structured concurrency
      import * './advanced/concur'
      edh'structured'concurrency # <- follow this bookmark to the section there
    }


    {## Apk/List/Dict Comprehension
     # - Comprehend items into containers

Both Haskell and Python have list comprehension syntax, Python further has dict and set comprehension syntax.

In Đ the comprehension (=<) operator can be used to pump iterated result values from a for-loop into a result container.

     #} {;

      # %% # Positional args comprehension
      ; () =< do i*i for i from 3..8

      # %% # Keyword args comphrehension
      ; () =< do ( @( "square'of'" ++ i )= i*i, ) for i from 3..8

      # %% # List comprehension
      ; [] =< do i*i for i from 3..8

      # %% # Dict comprehension
      {} =< do ( "square-of-" ++ i ): i*i for i from 3..8
      # %#
    }


    {## Pattern Matching
     # - With syntax closer to Haskell rather than Python

 Đ pattern matching syntax is closer to that of Haskell rather than Python. And unlike other languages, Đ pattern syntax is actually not hard-coded by the language grammar, it can be customized with an alternative implementation of the branch (->) operator, or even a fresh new operator functioning similarly. The pattern expression is just a regular Đ expression at left-hand-side of such an operator.

     #} {;
      # TODO demo diffs with Haskell/Python patterns

      edh'pattern'matching # <- follow this bookmark to detailed syntax and description in the grammar chapter
    }

  }


  {## Customizable Operators
   # - Operator definition like in Haskell, magic methods like in Python

On one end of the spectrum, the programming language APL prefers symbolic operators over words from natural langues, while many programming languages support only a fixed set of symbolic operators, typically including basic arithmetic operators.

Functional programming languages tend to enjoy flexible operators more than procedural languages, you can see Haskell allows full customization of infix operators, C++ and Julia support only fixed set of operators while allowing operator overloading. Python as a multi-paradigm language, is some special in its magic method mechanism, allowing the operand object at each side of an infix operator to customize the operation separately, yet following some protocol (NotImplemented semantics) to cooperate with unknown partners, though also, there is only a fixed set of operators in Python, no new operator can be defined.

Đ supports flexible infix operators quite like Haskell, and also supports object magic methods to customize operation behaviors like Python.

Actually with Đ defaulting semantics, operation customization is even more versatile then that in Haskell and Python.

   #} {;

    # Đ infix operators are fully customizable
    edh'infix'ops # <- follow this bookmark to detailed syntax and description in the grammar chapter

    # Đ object magic methods is semantically like that in Python, but use more friendly names (operator symbols quoted in parentheses)
    edh'infix'magics # <- follow this bookmark to detailed syntax and description in the grammar chapter

    # Applicability & defaulting semantics are advanced topics described in another chapter
    ; () => {; import * './advanced/appl' # <- navigate to there for elaboration
      edh'na'semantics # <- follow this bookmark to the specific section there
    }

  }


  {## Partially Apply Procedures
   # - `partial()` resembles the same utility in Python

We are not currying Đ procedures, but we have `partial()` resembling the utility with related purpose as in Python.

   #} {;
    {## Partially Apply Procedures #}
    export edh'partial = bookmark()

    # %% # Take this simple procedure for example
    method f( a, b, c, ) {
      console.print( 'This is f()', a=a, b=b, c=c, )
    }

    # You can partially apply it like this
    f1 = partial ( 1, 2 ) ( f )

    # Or this more idiomatic form
    let f2 = f|partial( 1, 2 )

    # Or instead of a `let` statement, write it like this:
    f3 = ( f|partial( 1, 2 ) )
    # %# Note the pipe (|) operator has a rather low precedence -5, which is even lower than the assign (=) operator's precedence 0, so if not writing it as a `let` statement, parenthesis is necessary

    # %% # Usage of the partially called procedure is identical
    f1( 3 )

    # %% #
    f2( 5 )

    # %% #
    f3( 7 )

    # %# Note that as well as in Python, partially call with keyword arguments works as well, and partial calls can even be chained, with gradually more arguments.
    # TODO code cells to demo that

    # %#
  }


  {## Decorator
   # - Python decorator goes more general in Đ

Python decorator is a syntactic sugar for application of higher order functions as part of the declaration of a new function.

Inspired by Haskell, Đ introduces the procedure call ($) operator (called function application operator in Haskell), it works in places where Python decorators would, though with a little different syntax. Also it works even more generally in Đ.

In addition to ($), there is also the pipe (|) operator with just the oparands flipped, so utility procedure usages like `show( xx )` `repr( xx )` etc. can be written with sugar syntax like `show$ xx`, `repr$ xx`, and `xx |show` `xx |repr`.

   #} {;
    {## Decorator #}
    export edh'decorator = bookmark()

    {#
     # Take a typical Python `property` decorator as example

```python

class P:

  def __init__(self, x):
    self._x = x

  @property
  def x(self):
    return self._x

  @x.setter
  def x(self, new_x):
    self._x = new_x

o = P(3)

o.x = 5

o.x

```

Written equivalently in Đ like the following:

     #}

    # %% #
    class P {

      method __init__( x as this._x ) pass

      property$
      method x() this._x

      setter$
      method x( new'x ) {
        this._x = new'x
      }

    }

    o = P(3)

    o.x = 5

    o.x

    # %#


    # %% # A decorator is usually written in the host language, but as well, it can be written in Đ the surface language, in form of an interpreter procedure

    interpreter decor( callerScope: scope, fe ) case callerScope.eval( fe ) of { f } -> {
      callerScope.eval( expr method @(f.name) ( ***apk ) {
          console.info<| 'Calling procedure `' ++ {$ f.name $} ++ '` with: ' ++ apk
          {$ f $} ( ***apk )
      } )
    }

    # %% # And used like this

    decor$
    method g ( a, b, c ) {
      console.info<| 'This is g(), we have: ' ++ ( a=a, b=b, c=c, )
    }

    # %% # The decorated procedure can be used straight forward
    g( 1, 2, 3 )

    # %#
  }


  {## Equal vs Identical
   # - Beyond the `==` operator

 Most programming languages use the `==` operator for equality tests, there are more for the whole story.

 In Python, there is also the `is` operator for identity test, it uses memory address for major cases, with some special treatment, e.g. w.r.t. int objects.

 In JavaScript, there is also the `===` operator for uncoercing equality test, solving misfortune with the coercing `==` operator.

Identity equality and instant equality should be separately reasoned about, especially when immutable values and mutable values are both under consideration. Equality can change after objects get mutated, but many programming languages don't address this semantics enough, leaving gotchas for unworried programmers to create buggy software.

And it's actually a bit more complicated in Đ as named values (term definitions) is also involved.

   #} {;
    {## Equal vs Identical #}
    export edh'equal'vs'identical = bookmark()

    edh'equalities # <- follow this bookmark to the detailed description in the grammar chapter
  }


  {## Named Values / Term Definitions
   # - Got the familiar (:=) operator for definition
   #} {;
    edh'term'def # <- follow this bookmark to details in the grammar chapter,
    # or just run following cells to get the feel

    # %% # make sure to run this cell before the ones following it
    π := 3.14

    # %% # this prints its name, not value
    repr( π )

    # %% # after arithmetics, it is no more a term,
    repr( π * 1 ) # just an immutable numeric value

    # %% # while type of a term comes from its value
    type( π )

    # %% # and Đ knows it being a term, and can show that accordingly
    show( π )

    # %% # otherwise it's can be used just like an attribute
    r = 1.58
    C = 2 * π * r

    # %#
  }


  {## Đ Vocabulary for Nullability
   # - nil, null, None, Nothing and friends
   #} {;
    edh'nullability # <- follow this bookmark to details in the grammar chapter,
    # or just run following cells to get the feel

    # %% # `nil` will not be printed by REPL
    nil

    # %%
    type( nil ) is nil

    # %% `null()` is the null-test procedure, relatable to the `null`
    # function as in Haskell, but semantically more like:
    #  - Negated *Truth Value Testing* as in Python
    #  https://docs.python.org/3/library/stdtypes.html#truth-value-testing
    # And
    #  - *Falsy Testing* as in JavaScript
    #  https://developer.mozilla.org/en-US/docs/Glossary/Falsy
    # For a dynamic language
    null( nil )
    # %%
    null( 0 )
    # %%
    null( 1 )

    # %% # Note a procedure value will always be *truthy*
    null( null ) # recognize the result please

    # With the mechanism to define named values (i.e. terms), some named *nil* values can be defined for special purpose:

    # %%
    None
    # %%
    Nothing

    # %%
    show( None )
    # %%
    show( Nothing )

    # %%
    None == Nothing
    # %%
    None is Nothing

    # %%
    None == nil
    # %%
    None is nil

    # %%
    Nothing == nil
    # %%
    Nothing is nil

    # %#
  }

}


{## Object-Oriented, along with Simpler Values
 # - Everything is a Value (instead of Object) in Đ

Everything is an Object in Python / Smalltalk, Đ seeks to be as *Object-Oriented* as Python, but *NOT* everything is an object here, such as numbers, strings, and procedures. Also, intrinsic mutable containers, namely dict and list are not object in Đ; neither for immutable containers, namely pairs and arguments packs.

 #} {;

  # The Đ Object System is an advanced topic in a dedicated chapter
  import * './advanced/objs' # <- follow this import source to that chapter

  # A brief introduction lives in the grammar chapter as well, for its compositional multiple inheritance, and how both class based inheritance and prototype based inheritance are supported.
  edh'objs'inheritance # <- follow this bookmark to the details in the grammar chapter


  {## Class Based Inheritance similar to Python
   # - Class based, C3 linearized multiple inheritance, with magic methods

Except customizable meta class, Đ mimics all aspects of Python's object system, including C3 linearization w.r.t. multiple inheritance, properties, and magic methods with `NotImplemented` semantics.

   #} {;
    {## Class Based Inheritance similar to Python #}
    export edh'oo'similar'to'py = bookmark()

    edh'cls'inheritance # <- follow this bookmark to the details in the grammar chapter

    # TODO typical Python class hierarchy and the Đ translation here


    {## Data Classes
     # - Python PEP-557 (Data Classes) got dedicated syntax in Đ

Đ supports all features of Python "Data Classes", yet with the dedicated `data` keyword for syntax
  https://www.python.org/dev/peps/pep-0557

Beyond PEP-557 features, Đ data classes especially shines in pattern matching use cases, the `__match__()` magic method allows a data class to parse arbitrary values into data instances, and a pattern can extract just data fields of interest from the result, comes rather convenient.

     #} {;
      edh'data'classes # <- follow this bookmark to the details in the grammar chapter
    }


    {## Magic Methods
     # - Python equivalent ones and more

Đ object magic methods is semantically like that in Python, but unlike Python where only a fixed set of operators have corresponding specially named magic methods, in Đ all infix operators (even ones merely declared but not implemented), including custom defined new ones, can be customized with magic methods. To acommodate that, magic method name is the corresponding operator symbol quoted in a pair of parentheses, for objects at lhs of the operator; and for objects at rhs of the operator, a trailing dot (.) is added to the operator symbol, then quoted in parentheses to form the magic method name. As dot (.) is not a valid operator character in Đ, so it can not be ambiguous.

Đ applicability semantics is richer then Python's mere `NotImplemented`, further with defaulting, operation customization is even more versatile then that in Haskell and Python.

     #} {;
      edh'magic'mths # <- follow this bookmark to the details in the grammar chapter

      # `NA` in Đ resembling `NotImplemented` in Python, it is 1st class value, and its more expanded form - default expressions can be further used to indicate less preferred applicabilities
      edh'defaulting'values # <- follow this bookmark to the details in the grammar chapter

      # The Đ Applicability Semantics is an advanced topic a dedicated chapter
      import * './advanced/appl' # <- follow this import source to that chapter
    }

  }


  {## Prototype Based Inheritance similar to JavaScript
   # - Prototype based multiple inheritance

Đ supports prototype based inheritance like JavaScript does, and even better, multiple prototype chains work as well.

   #} {;
    {## Prototype Based Inheritance similar to JavaScript #}
    export edh'oo'similar'to'js = bookmark()

    edh'proto'inheritance # <- follow this bookmark to the details in the grammar chapter

    # TODO typical JavaScript class hierarchy and the Đ translation here

  }


  {## Beyond `this` or `self` Reference
   # - Compositional object structure

Đ follows JavaScript/Java/C++ to use `this` keyword, instead of Python's conventional `self`, however this is not just a keyword difference.

There is additionally `that` reference in Đ, it solves [Object Schizophrenia](https://en.wikipedia.org/wiki/Schizophrenia_(object-oriented_programming)) problem. As well it solves problem akin to the [Slicing problem](https://en.wikipedia.org/wiki/Object_slicing) of C++, you just need to pass `that` instead of `this` around.

Intrinsically, Đ objects are compositional instances, the structure reflects the [Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) principle, composition and inheritance are actually unified in Đ object system.

   #} {;
    {## Beyond `this` or `self` Reference #}
    export edh'compositional'objs = bookmark()

    edh'mth'binding # <- follow this bookmark to the details in the grammar chapter
  }


  {## Object Identity Made Right
   # - Objects are wrongly assumed to be identified by memory address

Check out this flaw of Python:

```python
>>> x = 101
>>> y = 101
>>> x is y
True

>>> x = 1001
>>> y = 1001
>>> x is y
False
```

There is no similar problem with Đ in the first place, as numbers are not object at all, they are immutable values identified soly by the value itself.

Further more, Đ allows an alternative identity value to be associated with an object, as its magic `__id__` attribute (which should never change identity of course).

Data classes take advantage of this mechanism, so two data instances are considered identical iif they are of the same data class, and all their data fields are identical respectively.

   #} {;

    # %% # The `id()` utility in Đ resembls that in Python, but works more correctly
    data P(x, y) pass

    origin = P(0, 0)
    id$ origin

    # %% # Under the hood, a data class assigns the magic `__id__` attribute automatically
    origin.__id__

    # %% # So identity equality test works reasonably right
    origin is P(0, 0)

    # %#
  }


  {## Virtual Attributes
   # - For non-object values to have object look & feel
   #} {;
    edh'virtual'attrs # <- follow this bookmark to the details in the grammar chapter

    # %% # Let's have a dict value, remind its type is `Dict` type
    d = { 'name': 'Yue', 'city': 'Chongqing', }
    type(d)
    # %% # Then obtain number of items in it as if there's a `size` attribute on it
    d.size
    # %% # This is possible because Đ does the translation under the hood, to something like:
    __Dict_size__(d)
    # %% # See the result is the same? Then checkout there really is such a method procedure:
    show$ __Dict_size__
    # %% # Also be noted that
    d.push( 'year', 2021, )
    # %% # is translated to
    __Dict_push__(d)( 'year', 2021, )
    # %% # Now you see the dict can be actually updated this way
    d
    # %# How convenient.
  }

}


{## Expression Values and Scope Wrapprs
 # - Here is why Đ is even More dynamic than Python

Đ fosters dynamic evaluation of any expression, anytime, anywhere.

Expression is a 1st class type of values in Đ.

A scope can be wrapped as an object, for reflective evaluation of Đ expressions, or direct attribute manipulation to be done as in that scope.

 #} {;
  edh'exprs'in'scopes # <- follow this bookmark to the details in grammar chapter

  {## The `expr` Expression
   # - Literal expressions

An arbitrary expression following the `expr` keyword will create a literal value of `Expr` type.

At the time an `expr` is defined, immediate values can be interpolated into the defined literal expression value, each immediate expression quoted within a pair of curly braces augmented with '$' will be evaluated at the `expr` definition time, and interpolated as literal values embedded in the result expression.

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark()

    # %% # It can be assigned as an attribute of current scope like any other values
    x = expr a + b * c

    type$ x
    # %# See its type

    # %% # Its textual representation is its original source text
    repr$ x

    # %# An expression created this way will have its original source reserved, to serve as its `repr`.


    # %% # To demonstrate the interpolation
    let ( a, b, c, ) = ( 3, 7, 5, )
    x' = expr a + {$ b*c $} * c

    repr$ x'
    # %# See how the expression between `{$` and `$}` is eagerly evaluated and interpolated

    # A literal value interpolated will give its `repr` in place of the original `{$ $}` segment, for `repr` of the whole literal expression value.

    # %% # Check it evaluated in the reflective way
    scope().eval( x' )

    # %# Note that `scope().eval()` is described in the next section below

  }


  {## Scope Wrappers
   # - Scopes wrapped as objects

`scope` is a class, thus an object constructor, comes with the Đ runtime.

   #} {;
    {## Scope Wrappers #}
    export edh'scope'wrappers = bookmark()


    # Without argument, everytime you call `scope()`, it creates an object wrapping the scope of the calling site.

    # %% # Let's use a hierarchy of nested procedure scopes for the demonstration
    method f() {
      # Put these into the outer procedure scope
      let ( c, d, ) = ( 2, 8, )

      # Call an ad-hoc arrow procedure to get its procedure scope wrapped, for later observation of lexical structure of scopes with that as the tip
      return ()|() => {
        # Put these into the inner procedure scope
        let ( a, b, ) = ( 7, 3, )

        # Wrap and return current scope
        return scope()
      }
    }
    s = f()
    'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()
    # %#

    # %% # Evaluate some expression in the outer scope and see how it's changed
    s.outer.eval(expr
      e = c / d
    )
    dir$ s.outer

    # %% # Evaluate some expression in the inner scope and see how it's changed
    s.eval(expr
      e = 3*a - 5*b + c - 7*d
    )
    dir$ s
    # %#


    # %% # If an object is passed as ctor argument, it creates a wrapper object for the object scope of that object
    class C pass
    o = C()
    s = scope(o)
    s.attrs()
    # %# It's empty as no attribute is defined by a bare object

    # %% # We can put some attributes into it
    s.put( a= 3, c= 7, b= 5, )
    dir$ s

    # %% # Expression evaluation works with an object scope as well
    s.eval(expr
      d = a + b / c
    )
    dir$ s
    # %#

  }


  {## Expression Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3-arg operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expression Arguments to Procedures #}
    export edh'expr'args = bookmark()

    # %% # It's repr is the original source
    x' = expr a + b * c

    # %% # See its AST etc. by desc it
    desc$ x'

    # %% # While it can be reflectively evaluated as well
    s.eval( x' )

    # %#

  }


  {## Code as Data
   # - A runnable piece of Đ code is just data from the perspective of the host language/runtime

Not as homoiconic as LISP family languages, but Đ code can define expressions as first class value and evaluate them in designated contexts as demonstrated above.

Further more, Đ host procedures (written in Haskell) see Đ AST directly, ASTs can be parsed from source text, or generated on the fly then put to interpreted execution.

TODO expand this section.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark()
  }

}
